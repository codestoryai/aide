diff --git a/src/vs/workbench/contrib/csChat/browser/actions/csChatActions.ts b/src/vs/workbench/contrib/csChat/browser/actions/csChatActions.ts
index 0ae0c38150c..e776928802f 100644
--- a/src/vs/workbench/contrib/csChat/browser/actions/csChatActions.ts
+++ b/src/vs/workbench/contrib/csChat/browser/actions/csChatActions.ts
@@ -8,41 +8,52 @@ import { KeyCode, KeyMod } from 'vs/base/common/keyCodes';
 import { Disposable } from 'vs/base/common/lifecycle';
 import { ThemeIcon } from 'vs/base/common/themables';
 import { ICodeEditor } from 'vs/editor/browser/editorBrowser';
-import { EditorAction, EditorAction2, ServicesAccessor, registerEditorAction } from 'vs/editor/browser/editorExtensions';
+import { EditorAction2, ServicesAccessor } from 'vs/editor/browser/editorExtensions';
 import { ICodeEditorService } from 'vs/editor/browser/services/codeEditorService';
-import { IWorkbenchContributionsRegistry, Extensions as WorkbenchExtensions } from 'vs/workbench/common/contributions';
 import { EditorContextKeys } from 'vs/editor/common/editorContextKeys';
-import { localize } from 'vs/nls';
+import { localize, localize2 } from 'vs/nls';
 import { Action2, IAction2Options, MenuId, registerAction2 } from 'vs/platform/actions/common/actions';
 import { ContextKeyExpr } from 'vs/platform/contextkey/common/contextkey';
 import { KeybindingWeight } from 'vs/platform/keybinding/common/keybindingsRegistry';
 import { IQuickInputService, IQuickPickItem } from 'vs/platform/quickinput/common/quickInput';
+import { Registry } from 'vs/platform/registry/common/platform';
 import { ViewAction } from 'vs/workbench/browser/parts/views/viewPane';
+import { IWorkbenchContributionsRegistry, Extensions as WorkbenchExtensions } from 'vs/workbench/common/contributions';
+import { IViewsService } from 'vs/workbench/common/views';
+import { AccessibilityHelpAction } from 'vs/workbench/contrib/accessibility/browser/accessibleViewActions';
 import { runAccessibilityHelpAction } from 'vs/workbench/contrib/chat/browser/actions/chatAccessibilityHelp';
 import { IChatWidgetService } from 'vs/workbench/contrib/chat/browser/chat';
 import { IChatEditorOptions } from 'vs/workbench/contrib/chat/browser/chatEditor';
 import { ChatEditorInput } from 'vs/workbench/contrib/chat/browser/chatEditorInput';
 import { ChatViewPane } from 'vs/workbench/contrib/chat/browser/chatViewPane';
-import { CONTEXT_IN_CHAT_INPUT, CONTEXT_IN_CHAT_SESSION, CONTEXT_PROVIDER_EXISTS, CONTEXT_REQUEST, CONTEXT_RESPONSE } from 'vs/workbench/contrib/chat/common/chatContextKeys';
+import { IChatAgentService } from 'vs/workbench/contrib/chat/common/chatAgents';
+import { CONTEXT_CHAT_INPUT_CURSOR_AT_TOP, CONTEXT_IN_CHAT_INPUT, CONTEXT_IN_CHAT_SESSION, CONTEXT_PROVIDER_EXISTS, CONTEXT_REQUEST, CONTEXT_RESPONSE } from 'vs/workbench/contrib/chat/common/chatContextKeys';
+import { IChatContributionService } from 'vs/workbench/contrib/chat/common/chatContributionService';
+import { chatAgentLeader } from 'vs/workbench/contrib/chat/common/chatParserTypes';
 import { IChatDetail, IChatService } from 'vs/workbench/contrib/chat/common/chatService';
 import { IChatWidgetHistoryService } from 'vs/workbench/contrib/chat/common/chatWidgetHistoryService';
 import { IEditorService } from 'vs/workbench/services/editor/common/editorService';
-import { Registry } from 'vs/platform/registry/common/platform';
 import { LifecyclePhase } from 'vs/workbench/services/lifecycle/common/lifecycle';
-import { AccessibilityHelpAction } from 'vs/workbench/contrib/accessibility/browser/accessibleViewActions';
-import { IChatAgentService } from 'vs/workbench/contrib/chat/common/chatAgents';
-import { chatAgentLeader } from 'vs/workbench/contrib/chat/common/chatParserTypes';
-import { IChatContributionService } from 'vs/workbench/contrib/chat/common/chatContributionService';
-import { IViewsService } from 'vs/workbench/common/views';
 
 export const CHAT_CATEGORY = { value: localize('chat.category', "Chat"), original: 'Chat' };
 export const CHAT_OPEN_ACTION_ID = 'workbench.action.chat.open';
 
-class QuickChatGlobalAction extends Action2 {
+export interface IChatViewOpenOptions {
+	/**
+	 * The query for quick chat.
+	 */
+	query: string;
+	/**
+	 * Whether the query is partial and will await more input from the user.
+	 */
+	isPartialQuery?: boolean;
+}
+
+class OpenChatGlobalAction extends Action2 {
 	constructor() {
 		super({
 			id: CHAT_OPEN_ACTION_ID,
-			title: { value: localize('quickChat', "Quick Chat"), original: 'Quick Chat' },
+			title: localize2('openChat', "Open Chat"),
 			precondition: CONTEXT_PROVIDER_EXISTS,
 			icon: Codicon.commentDiscussion,
 			f1: false,
@@ -57,7 +68,9 @@ class QuickChatGlobalAction extends Action2 {
 		});
 	}
 
-	override async run(accessor: ServicesAccessor, query?: string): Promise<void> {
+	override async run(accessor: ServicesAccessor, opts?: string | IChatViewOpenOptions): Promise<void> {
+		opts = typeof opts === 'string' ? { query: opts } : opts;
+
 		const chatService = accessor.get(IChatService);
 		const chatWidgetService = accessor.get(IChatWidgetService);
 		const providers = chatService.getProviderInfos();
@@ -68,68 +81,79 @@ class QuickChatGlobalAction extends Action2 {
 		if (!chatWidget) {
 			return;
 		}
-		if (query) {
-			chatWidget.acceptInput(query);
+		if (opts?.query) {
+			if (opts.isPartialQuery) {
+				chatWidget.setInput(opts.query);
+			} else {
+				chatWidget.acceptInput(opts.query);
+			}
 		}
+
 		chatWidget.focusInput();
 	}
 }
 
-export function registerChatActions() {
-	registerAction2(QuickChatGlobalAction);
-	registerEditorAction(class ChatAcceptInput extends EditorAction {
-		constructor() {
-			super({
-				id: 'chat.action.acceptInput',
-				label: localize({ key: 'actions.chat.acceptInput', comment: ['Apply input from the chat input box'] }, "Accept Chat Input"),
-				alias: 'Accept Chat Input',
-				precondition: CONTEXT_IN_CHAT_INPUT,
-				kbOpts: {
-					kbExpr: EditorContextKeys.textInputFocus,
-					primary: KeyCode.Enter,
-					weight: KeybindingWeight.EditorContrib
-				}
-			});
-		}
+export class ChatSubmitSecondaryAgentEditorAction extends EditorAction2 {
+	static readonly ID = 'workbench.action.chat.submitSecondaryAgent';
 
-		run(accessor: ServicesAccessor, editor: ICodeEditor): void | Promise<void> {
-			const editorUri = editor.getModel()?.uri;
-			if (editorUri) {
-				const widgetService = accessor.get(IChatWidgetService);
-				widgetService.getWidgetByInputUri(editorUri)?.acceptInput();
+	constructor() {
+		super({
+			id: ChatSubmitSecondaryAgentEditorAction.ID,
+			title: localize2({ key: 'actions.chat.submitSecondaryAgent', comment: ['Send input from the chat input box to the secondary agent'] }, "Submit to Secondary Agent"),
+			precondition: CONTEXT_IN_CHAT_INPUT,
+			keybinding: {
+				when: EditorContextKeys.textInputFocus,
+				primary: KeyMod.CtrlCmd | KeyCode.Enter,
+				weight: KeybindingWeight.EditorContrib
 			}
-		}
-	});
+		});
+	}
 
-	registerEditorAction(class ChatSubmitSecondaryAgent extends EditorAction {
-		constructor() {
-			super({
-				id: 'chat.action.submitSecondaryAgent',
-				label: localize({ key: 'actions.chat.submitSecondaryAgent', comment: ['Send input from the chat input box to the secondary agent'] }, "Submit to Secondary Agent"),
-				alias: 'Submit to Secondary Agent',
-				precondition: CONTEXT_IN_CHAT_INPUT,
-				kbOpts: {
-					kbExpr: EditorContextKeys.textInputFocus,
-					primary: KeyMod.CtrlCmd | KeyCode.Enter,
-					weight: KeybindingWeight.EditorContrib
-				}
-			});
+	runEditorCommand(accessor: ServicesAccessor, editor: ICodeEditor): void | Promise<void> {
+		const editorUri = editor.getModel()?.uri;
+		if (editorUri) {
+			const agentService = accessor.get(IChatAgentService);
+			const secondaryAgent = agentService.getSecondaryAgent();
+			if (!secondaryAgent) {
+				return;
+			}
+
+			const widgetService = accessor.get(IChatWidgetService);
+			widgetService.getWidgetByInputUri(editorUri)?.acceptInputWithPrefix(`${chatAgentLeader}${secondaryAgent.id}`);
 		}
+	}
+}
 
-		run(accessor: ServicesAccessor, editor: ICodeEditor): void | Promise<void> {
-			const editorUri = editor.getModel()?.uri;
-			if (editorUri) {
-				const agentService = accessor.get(IChatAgentService);
-				const secondaryAgent = agentService.getSecondaryAgent();
-				if (!secondaryAgent) {
-					return;
-				}
+export class ChatSubmitEditorAction extends EditorAction2 {
+	static readonly ID = 'workbench.action.chat.acceptInput';
 
-				const widgetService = accessor.get(IChatWidgetService);
-				widgetService.getWidgetByInputUri(editorUri)?.acceptInputWithPrefix(`${chatAgentLeader}${secondaryAgent.id}`);
+	constructor() {
+		super({
+			id: ChatSubmitEditorAction.ID,
+			title: localize2({ key: 'actions.chat.submit', comment: ['Apply input from the chat input box'] }, "Submit"),
+			precondition: CONTEXT_IN_CHAT_INPUT,
+			keybinding: {
+				when: EditorContextKeys.textInputFocus,
+				primary: KeyCode.Enter,
+				weight: KeybindingWeight.EditorContrib
 			}
+		});
+	}
+
+	runEditorCommand(accessor: ServicesAccessor, editor: ICodeEditor): void | Promise<void> {
+		const editorUri = editor.getModel()?.uri;
+		if (editorUri) {
+			const widgetService = accessor.get(IChatWidgetService);
+			widgetService.getWidgetByInputUri(editorUri)?.acceptInput();
 		}
-	});
+	}
+}
+
+export function registerChatActions() {
+	registerAction2(OpenChatGlobalAction);
+	registerAction2(ChatSubmitEditorAction);
+
+	registerAction2(ChatSubmitSecondaryAgentEditorAction);
 
 	registerAction2(class ClearChatHistoryAction extends Action2 {
 		constructor() {
@@ -155,7 +179,7 @@ export function registerChatActions() {
 			super({
 				id: 'chat.action.focus',
 				title: { value: localize('actions.interactiveSession.focus', "Focus Chat List"), original: 'Focus Chat List' },
-				precondition: CONTEXT_IN_CHAT_INPUT,
+				precondition: ContextKeyExpr.and(CONTEXT_IN_CHAT_INPUT, CONTEXT_CHAT_INPUT_CURSOR_AT_TOP),
 				category: CHAT_CATEGORY,
 				keybinding: {
 					when: EditorContextKeys.textInputFocus,
@@ -200,7 +224,7 @@ export function registerChatActions() {
 				keybinding: {
 					primary: KeyMod.CtrlCmd | KeyCode.DownArrow,
 					weight: KeybindingWeight.WorkbenchContrib,
-					when: ContextKeyExpr.and(CONTEXT_IN_CHAT_SESSION, ContextKeyExpr.not(EditorContextKeys.focus.key))
+					when: ContextKeyExpr.and(CONTEXT_IN_CHAT_SESSION, CONTEXT_IN_CHAT_INPUT.negate())
 				}
 			});
 		}
diff --git a/src/vs/workbench/contrib/csChat/browser/actions/csChatClearActions.ts b/src/vs/workbench/contrib/csChat/browser/actions/csChatClearActions.ts
index d45fad58121..dd15cd78e37 100644
--- a/src/vs/workbench/contrib/csChat/browser/actions/csChatClearActions.ts
+++ b/src/vs/workbench/contrib/csChat/browser/actions/csChatClearActions.ts
@@ -81,6 +81,7 @@ export function registerClearActions() {
 
 			announceChatCleared(accessor);
 			widget.clear();
+			widget.focusInput();
 		}
 	});
 }
@@ -110,6 +111,7 @@ export function getClearAction(viewId: string, providerId: string) {
 		async runInView(accessor: ServicesAccessor, view: ChatViewPane) {
 			announceChatCleared(accessor);
 			await view.clear();
+			view.widget.focusInput();
 		}
 	};
 }
diff --git a/src/vs/workbench/contrib/csChat/browser/actions/csChatCodeblockActions.ts b/src/vs/workbench/contrib/csChat/browser/actions/csChatCodeblockActions.ts
index d0713c603ce..bbf5ba106b9 100644
--- a/src/vs/workbench/contrib/csChat/browser/actions/csChatCodeblockActions.ts
+++ b/src/vs/workbench/contrib/csChat/browser/actions/csChatCodeblockActions.ts
@@ -27,8 +27,8 @@ import { IUntitledTextResourceEditorInput } from 'vs/workbench/common/editor';
 import { CHAT_CATEGORY } from 'vs/workbench/contrib/chat/browser/actions/chatActions';
 import { IChatWidgetService } from 'vs/workbench/contrib/chat/browser/chat';
 import { ICodeBlockActionContext } from 'vs/workbench/contrib/chat/browser/codeBlockPart';
-import { CONTEXT_IN_CHAT_SESSION, CONTEXT_PROVIDER_EXISTS } from 'vs/workbench/contrib/chat/common/chatContextKeys';
-import { IChatService, IDocumentContext, InteractiveSessionCopyKind } from 'vs/workbench/contrib/chat/common/chatService';
+import { CONTEXT_IN_CHAT_INPUT, CONTEXT_IN_CHAT_SESSION, CONTEXT_PROVIDER_EXISTS } from 'vs/workbench/contrib/chat/common/chatContextKeys';
+import { IChatService, IDocumentContext, ChatAgentCopyKind } from 'vs/workbench/contrib/chat/common/chatService';
 import { IChatResponseViewModel, isResponseVM } from 'vs/workbench/contrib/chat/common/chatViewModel';
 import { CTX_INLINE_CHAT_VISIBLE } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
 import { insertCell } from 'vs/workbench/contrib/notebook/browser/controller/cellOperations';
@@ -114,7 +114,7 @@ export function registerChatCodeBlockActions() {
 					action: {
 						kind: 'copy',
 						codeBlockIndex: context.codeBlockIndex,
-						copyType: InteractiveSessionCopyKind.Toolbar,
+						copyKind: ChatAgentCopyKind.Toolbar,
 						copiedCharacters: context.code.length,
 						totalCharacters: context.code.length,
 						copiedText: context.code,
@@ -157,7 +157,7 @@ export function registerChatCodeBlockActions() {
 			action: {
 				kind: 'copy',
 				codeBlockIndex: context.codeBlockIndex,
-				copyType: InteractiveSessionCopyKind.Action,
+				copyKind: ChatAgentCopyKind.Action,
 				copiedText,
 				copiedCharacters: copiedText.length,
 				totalCharacters,
@@ -191,7 +191,7 @@ export function registerChatCodeBlockActions() {
 					when: CONTEXT_IN_CHAT_SESSION,
 				},
 				keybinding: {
-					when: CONTEXT_IN_CHAT_SESSION,
+					when: ContextKeyExpr.and(CONTEXT_IN_CHAT_SESSION, CONTEXT_IN_CHAT_INPUT.negate()),
 					primary: KeyMod.CtrlCmd | KeyCode.Enter,
 					mac: { primary: KeyMod.WinCtrl | KeyCode.Enter },
 					weight: KeybindingWeight.WorkbenchContrib
@@ -466,7 +466,7 @@ export function registerChatCodeBlockActions() {
 				terminalGroupService.showPanel(true);
 			}
 
-			terminal.sendText(context.code, false, true);
+			terminal.runCommand(context.code, false);
 
 			if (isResponseVM(context.element)) {
 				chatService.notifyUserAction({
diff --git a/src/vs/workbench/contrib/csChat/browser/actions/csChatExecuteActions.ts b/src/vs/workbench/contrib/csChat/browser/actions/csChatExecuteActions.ts
index 817844feb3b..9798132da98 100644
--- a/src/vs/workbench/contrib/csChat/browser/actions/csChatExecuteActions.ts
+++ b/src/vs/workbench/contrib/csChat/browser/actions/csChatExecuteActions.ts
@@ -35,22 +35,21 @@ export class SubmitAction extends Action2 {
 				id: MenuId.ChatExecute,
 				when: CONTEXT_CHAT_REQUEST_IN_PROGRESS.negate(),
 				group: 'navigation',
-			}
+			},
 		});
 	}
 
 	run(accessor: ServicesAccessor, ...args: any[]) {
-		const context: IChatExecuteActionContext = args[0];
+		const context: IChatExecuteActionContext | undefined = args[0];
 
 		const widgetService = accessor.get(IChatWidgetService);
-		const widget = context.widget ?? widgetService.lastFocusedWidget;
-		widget?.acceptInput(context.inputValue);
+		const widget = context?.widget ?? widgetService.lastFocusedWidget;
+		widget?.acceptInput(context?.inputValue);
 	}
 }
 
 export function registerChatExecuteActions() {
 	registerAction2(SubmitAction);
-
 	registerAction2(class CancelAction extends Action2 {
 		constructor() {
 			super({
diff --git a/src/vs/workbench/contrib/csChat/browser/actions/csChatMoveActions.ts b/src/vs/workbench/contrib/csChat/browser/actions/csChatMoveActions.ts
index e7b68fa51b3..834c5eca7e1 100644
--- a/src/vs/workbench/contrib/csChat/browser/actions/csChatMoveActions.ts
+++ b/src/vs/workbench/contrib/csChat/browser/actions/csChatMoveActions.ts
@@ -6,7 +6,7 @@
 import { localize } from 'vs/nls';
 import { Action2, IAction2Options, MenuId, registerAction2 } from 'vs/platform/actions/common/actions';
 import { ContextKeyExpr } from 'vs/platform/contextkey/common/contextkey';
-import { IInstantiationService, ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';
+import { ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';
 import { ViewAction } from 'vs/workbench/browser/parts/views/viewPane';
 import { ActiveEditorContext } from 'vs/workbench/common/contextkeys';
 import { IViewsService } from 'vs/workbench/common/views';
@@ -19,7 +19,7 @@ import { CONTEXT_PROVIDER_EXISTS } from 'vs/workbench/contrib/chat/common/chatCo
 import { IChatContributionService } from 'vs/workbench/contrib/chat/common/chatContributionService';
 import { IChatService } from 'vs/workbench/contrib/chat/common/chatService';
 import { IEditorGroupsService } from 'vs/workbench/services/editor/common/editorGroupsService';
-import { IEditorService } from 'vs/workbench/services/editor/common/editorService';
+import { ACTIVE_GROUP, AUX_WINDOW_GROUP, IEditorService } from 'vs/workbench/services/editor/common/editorService';
 
 enum MoveToNewLocation {
 	Editor = 'Editor',
@@ -63,25 +63,11 @@ export function getMoveToAction(viewId: string, providerId: string, moveTo: Move
 				return;
 			}
 
-			const editorGroupService = accessor.get(IEditorGroupsService);
-			const instantiationService = accessor.get(IInstantiationService);
 			const editorService = accessor.get(IEditorService);
 			const sessionId = viewModel.sessionId;
 			view.clear();
 
-			switch (moveTo) {
-				case (MoveToNewLocation.Editor): {
-					await editorService.openEditor({ resource: ChatEditorInput.getNewEditorUri(), options: <IChatEditorOptions>{ target: { sessionId: viewModel.sessionId }, pinned: true } });
-					break;
-				}
-				case (MoveToNewLocation.Window): {
-					await openInNewWindow(instantiationService, editorGroupService, { target: { sessionId } });
-					break;
-				}
-				default: {
-					throw new Error(`Unexpected move to location : ${moveTo}`);
-				}
-			}
+			await editorService.openEditor({ resource: ChatEditorInput.getNewEditorUri(), options: <IChatEditorOptions>{ target: { sessionId }, pinned: true } }, moveTo === MoveToNewLocation.Window ? AUX_WINDOW_GROUP : ACTIVE_GROUP);
 		}
 	};
 }
@@ -156,26 +142,12 @@ async function executeMoveToAction(accessor: ServicesAccessor, moveTo: MoveToNew
 	const viewService = accessor.get(IViewsService);
 	const chatService = accessor.get(IChatService);
 	const editorService = accessor.get(IEditorService);
-	const instantiationService = accessor.get(IInstantiationService);
-	const editorGroupService = accessor.get(IEditorGroupsService);
 
 	const widget = widgetService.lastFocusedWidget;
 	if (!widget || !('viewId' in widget.viewContext)) {
 		const providerId = chatService.getProviderInfos()[0].id;
 
-		switch (moveTo) {
-			case (MoveToNewLocation.Editor): {
-				await editorService.openEditor({ resource: ChatEditorInput.getNewEditorUri(), options: <IChatEditorOptions>{ target: { providerId }, pinned: true } });
-				break;
-			}
-			case (MoveToNewLocation.Window): {
-				await openInNewWindow(instantiationService, editorGroupService, { target: { providerId } });
-				break;
-			}
-			default: {
-				throw new Error(`Unexpected move to location : ${moveTo}`);
-			}
-		}
+		await editorService.openEditor({ resource: ChatEditorInput.getNewEditorUri(), options: <IChatEditorOptions>{ target: { providerId }, pinned: true } }, moveTo === MoveToNewLocation.Window ? AUX_WINDOW_GROUP : ACTIVE_GROUP);
 		return;
 	}
 
@@ -188,24 +160,7 @@ async function executeMoveToAction(accessor: ServicesAccessor, moveTo: MoveToNew
 	const view = await viewService.openView(widget.viewContext.viewId) as ChatViewPane;
 	view.clear();
 
-	switch (moveTo) {
-		case (MoveToNewLocation.Editor): {
-			await editorService.openEditor({ resource: ChatEditorInput.getNewEditorUri(), options: <IChatEditorOptions>{ target: { sessionId: sessionId }, pinned: true } });
-			break;
-		}
-		case (MoveToNewLocation.Window): {
-			await openInNewWindow(instantiationService, editorGroupService, { target: { sessionId } });
-		}
-		default: {
-			throw new Error(`Unexpected move to location : ${moveTo}`);
-		}
-	}
-}
-
-async function openInNewWindow(intstantiationService: IInstantiationService, editorGroupService: IEditorGroupsService, options: IChatEditorOptions) {
-	const auxiliaryEditorPart = await editorGroupService.createAuxiliaryEditorPart();
-	const chatEditorInput = intstantiationService.createInstance(ChatEditorInput, ChatEditorInput.getNewEditorUri(), options);
-	await auxiliaryEditorPart.activeGroup.openEditor(chatEditorInput, { pinned: true });
+	await editorService.openEditor({ resource: ChatEditorInput.getNewEditorUri(), options: <IChatEditorOptions>{ target: { sessionId }, pinned: true } }, moveTo === MoveToNewLocation.Window ? AUX_WINDOW_GROUP : ACTIVE_GROUP);
 }
 
 async function moveToSidebar(accessor: ServicesAccessor): Promise<void> {
diff --git a/src/vs/workbench/contrib/csChat/browser/contrib/csChatDynamicReferences.ts b/src/vs/workbench/contrib/csChat/browser/contrib/csChatDynamicVariables.ts
similarity index 53%
rename from src/vs/workbench/contrib/csChat/browser/contrib/csChatDynamicReferences.ts
rename to src/vs/workbench/contrib/csChat/browser/contrib/csChatDynamicVariables.ts
index 1bbbb27ba9e..a2e9446011e 100644
--- a/src/vs/workbench/contrib/csChat/browser/contrib/csChatDynamicReferences.ts
+++ b/src/vs/workbench/contrib/csChat/browser/contrib/csChatDynamicVariables.ts
@@ -3,7 +3,8 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 
-import { MarkdownString } from 'vs/base/common/htmlContent';
+import { coalesce } from 'vs/base/common/arrays';
+import { IMarkdownString, MarkdownString } from 'vs/base/common/htmlContent';
 import { Disposable } from 'vs/base/common/lifecycle';
 import { basename } from 'vs/base/common/resources';
 import { URI } from 'vs/base/common/uri';
@@ -17,67 +18,97 @@ import { ILogService } from 'vs/platform/log/common/log';
 import { IQuickInputService } from 'vs/platform/quickinput/common/quickInput';
 import { IChatWidget } from 'vs/workbench/contrib/chat/browser/chat';
 import { ChatWidget, IChatWidgetContrib } from 'vs/workbench/contrib/chat/browser/chatWidget';
-import { IDynamicReference } from 'vs/workbench/contrib/chat/common/chatVariables';
+import { IChatRequestVariableValue, IDynamicVariable } from 'vs/workbench/contrib/chat/common/chatVariables';
 
-export const dynamicReferenceDecorationType = 'chat-dynamic-reference';
+export const dynamicVariableDecorationType = 'chat-dynamic-variable';
 
-export class ChatDynamicReferenceModel extends Disposable implements IChatWidgetContrib {
-	public static readonly ID = 'chatDynamicReferenceModel';
+export class ChatDynamicVariableModel extends Disposable implements IChatWidgetContrib {
+	public static readonly ID = 'chatDynamicVariableModel';
 
-	private readonly _references: IDynamicReference[] = [];
-	get references(): ReadonlyArray<IDynamicReference> {
-		return [...this._references];
+	private _variables: IDynamicVariable[] = [];
+	get variables(): ReadonlyArray<IDynamicVariable> {
+		return [...this._variables];
 	}
 
 	get id() {
-		return ChatDynamicReferenceModel.ID;
+		return ChatDynamicVariableModel.ID;
 	}
 
 	constructor(
 		private readonly widget: IChatWidget,
-		@ILabelService private readonly labelService: ILabelService
+		@ILabelService private readonly labelService: ILabelService,
+		@ILogService private readonly logService: ILogService,
 	) {
 		super();
 		this._register(widget.inputEditor.onDidChangeModelContent(e => {
 			e.changes.forEach(c => {
-				this._references.forEach((ref, i) => {
+				// Don't mutate entries in _variables, since they will be returned from the getter
+				this._variables = coalesce(this._variables.map(ref => {
 					if (Range.areIntersecting(ref.range, c.range)) {
 						// The reference text was changed, it's broken
-						this._references.splice(i, 1);
+						return null;
 					} else if (Range.compareRangesUsingStarts(ref.range, c.range) > 0) {
 						const delta = c.text.length - c.rangeLength;
-						ref.range = {
-							startLineNumber: ref.range.startLineNumber,
-							startColumn: ref.range.startColumn + delta,
-							endLineNumber: ref.range.endLineNumber,
-							endColumn: ref.range.endColumn + delta
+						return {
+							...ref,
+							range: {
+								startLineNumber: ref.range.startLineNumber,
+								startColumn: ref.range.startColumn + delta,
+								endLineNumber: ref.range.endLineNumber,
+								endColumn: ref.range.endColumn + delta
+							}
 						};
 					}
-				});
+
+					return ref;
+				}));
 			});
 
-			this.updateReferences();
+			this.updateDecorations();
 		}));
 	}
 
-	addReference(ref: IDynamicReference): void {
-		this._references.push(ref);
-		this.updateReferences();
+	getInputState(): any {
+		return this.variables;
 	}
 
-	private updateReferences(): void {
-		this.widget.inputEditor.setDecorationsByType('chat', dynamicReferenceDecorationType, this._references.map(r => (<IDecorationOptions>{
+	setInputState(s: any): void {
+		if (!Array.isArray(s)) {
+			// Something went wrong
+			this.logService.warn('ChatDynamicVariableModel.setInputState called with invalid state: ' + JSON.stringify(s));
+			return;
+		}
+
+		this._variables = s;
+		this.updateDecorations();
+	}
+
+	addReference(ref: IDynamicVariable): void {
+		this._variables.push(ref);
+		this.updateDecorations();
+	}
+
+	private updateDecorations(): void {
+		this.widget.inputEditor.setDecorationsByType('chat', dynamicVariableDecorationType, this._variables.map(r => (<IDecorationOptions>{
 			range: r.range,
-			hoverMessage: new MarkdownString(this.labelService.getUriLabel(r.data, { relative: true }))
+			hoverMessage: this.getHoverForReference(r)
 		})));
 	}
-}
 
-ChatWidget.CONTRIBS.push(ChatDynamicReferenceModel);
+	private getHoverForReference(ref: IDynamicVariable): string | IMarkdownString {
+		const value = ref.data[0];
+		if (URI.isUri(value.value)) {
+			return new MarkdownString(this.labelService.getUriLabel(value.value, { relative: true }));
+		} else {
+			return value.value.toString();
+		}
+	}
+}
 
+ChatWidget.CONTRIBS.push(ChatDynamicVariableModel);
 
 interface SelectAndInsertFileActionContext {
-	widget: ChatWidget;
+	widget: IChatWidget;
 	range: IRange;
 }
 
@@ -135,10 +166,46 @@ export class SelectAndInsertFileAction extends Action2 {
 			return;
 		}
 
-		context.widget.getContrib<ChatDynamicReferenceModel>(ChatDynamicReferenceModel.ID)?.addReference({
+		context.widget.getContrib<ChatDynamicVariableModel>(ChatDynamicVariableModel.ID)?.addReference({
 			range: { startLineNumber: range.startLineNumber, startColumn: range.startColumn, endLineNumber: range.endLineNumber, endColumn: range.startColumn + text.length },
-			data: resource
+			data: [{ level: 'full', value: resource }]
 		});
 	}
 }
 registerAction2(SelectAndInsertFileAction);
+
+export interface IAddDynamicVariableContext {
+	widget: IChatWidget;
+	range: IRange;
+	variableData: IChatRequestVariableValue[];
+}
+
+function isAddDynamicVariableContext(context: any): context is IAddDynamicVariableContext {
+	return 'widget' in context &&
+		'range' in context &&
+		'variableData' in context;
+}
+
+export class AddDynamicVariableAction extends Action2 {
+	static readonly ID = 'workbench.action.chat.addDynamicVariable';
+
+	constructor() {
+		super({
+			id: AddDynamicVariableAction.ID,
+			title: '' // not displayed
+		});
+	}
+
+	async run(accessor: ServicesAccessor, ...args: any[]) {
+		const context = args[0];
+		if (!isAddDynamicVariableContext(context)) {
+			return;
+		}
+
+		context.widget.getContrib<ChatDynamicVariableModel>(ChatDynamicVariableModel.ID)?.addReference({
+			range: context.range,
+			data: context.variableData
+		});
+	}
+}
+registerAction2(AddDynamicVariableAction);
diff --git a/src/vs/workbench/contrib/csChat/browser/contrib/csChatInputEditorContrib.ts b/src/vs/workbench/contrib/csChat/browser/contrib/csChatInputEditorContrib.ts
index a470b14d1e3..928c561c4df 100644
--- a/src/vs/workbench/contrib/csChat/browser/contrib/csChatInputEditorContrib.ts
+++ b/src/vs/workbench/contrib/csChat/browser/contrib/csChatInputEditorContrib.ts
@@ -9,7 +9,7 @@ import { Disposable, MutableDisposable } from 'vs/base/common/lifecycle';
 import { ICodeEditorService } from 'vs/editor/browser/services/codeEditorService';
 import { Position } from 'vs/editor/common/core/position';
 import { Range } from 'vs/editor/common/core/range';
-import { getWordAtText } from 'vs/editor/common/core/wordHelper';
+import { IWordAtPosition, getWordAtText } from 'vs/editor/common/core/wordHelper';
 import { IDecorationOptions } from 'vs/editor/common/editorCommon';
 import { CompletionContext, CompletionItem, CompletionItemKind, CompletionList } from 'vs/editor/common/languages';
 import { ITextModel } from 'vs/editor/common/model';
@@ -26,12 +26,12 @@ import { SubmitAction } from 'vs/workbench/contrib/chat/browser/actions/chatExec
 import { IChatWidget, IChatWidgetService } from 'vs/workbench/contrib/chat/browser/chat';
 import { ChatInputPart } from 'vs/workbench/contrib/chat/browser/chatInputPart';
 import { ChatWidget } from 'vs/workbench/contrib/chat/browser/chatWidget';
-import { SelectAndInsertFileAction, dynamicReferenceDecorationType } from 'vs/workbench/contrib/chat/browser/contrib/chatDynamicReferences';
+import { SelectAndInsertFileAction, dynamicVariableDecorationType } from 'vs/workbench/contrib/chat/browser/contrib/chatDynamicVariables';
 import { IChatAgentCommand, IChatAgentData, IChatAgentService } from 'vs/workbench/contrib/chat/common/chatAgents';
 import { chatSlashCommandBackground, chatSlashCommandForeground } from 'vs/workbench/contrib/chat/common/chatColors';
-import { ChatRequestAgentPart, ChatRequestAgentSubcommandPart, ChatRequestSlashCommandPart, ChatRequestTextPart, ChatRequestVariablePart, chatAgentLeader, chatSubcommandLeader, chatVariableLeader } from 'vs/workbench/contrib/chat/common/chatParserTypes';
+import { ChatRequestAgentPart, ChatRequestAgentSubcommandPart, ChatRequestSlashCommandPart, ChatRequestTextPart, ChatRequestVariablePart, IParsedChatRequestPart, chatAgentLeader, chatSubcommandLeader, chatVariableLeader } from 'vs/workbench/contrib/chat/common/chatParserTypes';
 import { ChatRequestParser } from 'vs/workbench/contrib/chat/common/chatRequestParser';
-import { IChatService, ISlashCommand } from 'vs/workbench/contrib/chat/common/chatService';
+import { IChatService } from 'vs/workbench/contrib/chat/common/chatService';
 import { IChatSlashCommandService } from 'vs/workbench/contrib/chat/common/chatSlashCommands';
 import { IChatVariablesService } from 'vs/workbench/contrib/chat/common/chatVariables';
 import { isResponseVM } from 'vs/workbench/contrib/chat/common/chatViewModel';
@@ -94,7 +94,7 @@ class InputEditorDecorations extends Disposable {
 
 	private updateRegisteredDecorationTypes() {
 		this.codeEditorService.removeDecorationType(variableTextDecorationType);
-		this.codeEditorService.removeDecorationType(dynamicReferenceDecorationType);
+		this.codeEditorService.removeDecorationType(dynamicVariableDecorationType);
 		this.codeEditorService.removeDecorationType(slashCommandTextDecorationType);
 
 		const theme = this.themeService.getColorTheme();
@@ -108,7 +108,7 @@ class InputEditorDecorations extends Disposable {
 			backgroundColor: theme.getColor(chatSlashCommandBackground)?.toString(),
 			borderRadius: '3px'
 		});
-		this.codeEditorService.registerDecorationType(decorationDescription, dynamicReferenceDecorationType, {
+		this.codeEditorService.registerDecorationType(decorationDescription, dynamicVariableDecorationType, {
 			color: theme.getColor(chatSlashCommandForeground)?.toString(),
 			backgroundColor: theme.getColor(chatSlashCommandBackground)?.toString(),
 			borderRadius: '3px'
@@ -160,15 +160,25 @@ class InputEditorDecorations extends Disposable {
 		const agentSubcommandPart = parsedRequest.find((p): p is ChatRequestAgentSubcommandPart => p instanceof ChatRequestAgentSubcommandPart);
 		const slashCommandPart = parsedRequest.find((p): p is ChatRequestSlashCommandPart => p instanceof ChatRequestSlashCommandPart);
 
+		const exactlyOneSpaceAfterPart = (part: IParsedChatRequestPart): boolean => {
+			const partIdx = parsedRequest.indexOf(part);
+			if (parsedRequest.length > partIdx + 2) {
+				return false;
+			}
+
+			const nextPart = parsedRequest[partIdx + 1];
+			return nextPart && nextPart instanceof ChatRequestTextPart && nextPart.text === ' ';
+		};
+
 		const onlyAgentAndWhitespace = agentPart && parsedRequest.every(p => p instanceof ChatRequestTextPart && !p.text.trim().length || p instanceof ChatRequestAgentPart);
 		if (onlyAgentAndWhitespace) {
 			// Agent reference with no other text - show the placeholder
-			if (agentPart.agent.metadata.description) {
+			if (agentPart.agent.metadata.description && exactlyOneSpaceAfterPart(agentPart)) {
 				placeholderDecoration = [{
 					range: {
-						startLineNumber: 1,
-						endLineNumber: 1,
-						startColumn: inputValue.length,
+						startLineNumber: agentPart.editorRange.startLineNumber,
+						endLineNumber: agentPart.editorRange.endLineNumber,
+						startColumn: agentPart.editorRange.endColumn + 1,
 						endColumn: 1000
 					},
 					renderOptions: {
@@ -186,12 +196,12 @@ class InputEditorDecorations extends Disposable {
 			// Agent reference and subcommand with no other text - show the placeholder
 			const isFollowupSlashCommand = this.previouslyUsedAgents.has(agentAndCommandToKey(agentPart.agent.id, agentSubcommandPart.command.name));
 			const shouldRenderFollowupPlaceholder = isFollowupSlashCommand && agentSubcommandPart.command.followupPlaceholder;
-			if (agentSubcommandPart?.command.description) {
+			if (agentSubcommandPart?.command.description && exactlyOneSpaceAfterPart(agentSubcommandPart)) {
 				placeholderDecoration = [{
 					range: {
-						startLineNumber: 1,
-						endLineNumber: 1,
-						startColumn: inputValue.length,
+						startLineNumber: agentSubcommandPart.editorRange.startLineNumber,
+						endLineNumber: agentSubcommandPart.editorRange.endLineNumber,
+						startColumn: agentSubcommandPart.editorRange.endColumn + 1,
 						endColumn: 1000
 					},
 					renderOptions: {
@@ -207,19 +217,17 @@ class InputEditorDecorations extends Disposable {
 		const onlySlashCommandAndWhitespace = slashCommandPart && parsedRequest.every(p => p instanceof ChatRequestTextPart && !p.text.trim().length || p instanceof ChatRequestSlashCommandPart);
 		if (onlySlashCommandAndWhitespace) {
 			// Command reference with no other text - show the placeholder
-			const isFollowupSlashCommand = this.previouslyUsedAgents.has(slashCommandPart.slashCommand.command);
-			const shouldRenderFollowupPlaceholder = isFollowupSlashCommand && slashCommandPart.slashCommand.followupPlaceholder;
-			if (shouldRenderFollowupPlaceholder || slashCommandPart.slashCommand.detail) {
+			if (slashCommandPart.slashCommand.detail && exactlyOneSpaceAfterPart(slashCommandPart)) {
 				placeholderDecoration = [{
 					range: {
-						startLineNumber: 1,
-						endLineNumber: 1,
-						startColumn: inputValue.length,
+						startLineNumber: slashCommandPart.editorRange.startLineNumber,
+						endLineNumber: slashCommandPart.editorRange.endLineNumber,
+						startColumn: slashCommandPart.editorRange.endColumn + 1,
 						endColumn: 1000
 					},
 					renderOptions: {
 						after: {
-							contentText: shouldRenderFollowupPlaceholder ? slashCommandPart.slashCommand.followupPlaceholder : slashCommandPart.slashCommand.detail,
+							contentText: slashCommandPart.slashCommand.detail,
 							color: this.getPlaceholderColor(),
 						}
 					}
@@ -293,14 +301,15 @@ class SlashCommandCompletions extends Disposable {
 		this._register(this.languageFeaturesService.completionProvider.register({ scheme: ChatInputPart.INPUT_SCHEME, hasAccessToAllModels: true }, {
 			_debugDisplayName: 'globalSlashCommands',
 			triggerCharacters: ['/'],
-			provideCompletionItems: async (model: ITextModel, _position: Position, _context: CompletionContext, _token: CancellationToken) => {
+			provideCompletionItems: async (model: ITextModel, position: Position, _context: CompletionContext, _token: CancellationToken) => {
 				const widget = this.chatWidgetService.getWidgetByInputUri(model.uri);
 				if (!widget || !widget.viewModel) {
 					return null;
 				}
 
-				if (!model.getValue().trim().match(/\/\w*/)) {
-					return;
+				const range = computeCompletionRanges(model, position, /\/\w*/g);
+				if (!range) {
+					return null;
 				}
 
 				const parsedRequest = (await this.instantiationService.createInstance(ChatRequestParser).parseChatRequest(widget.viewModel.sessionId, model.getValue())).parts;
@@ -316,7 +325,7 @@ class SlashCommandCompletions extends Disposable {
 				}
 
 				return <CompletionList>{
-					suggestions: sortSlashCommandsByYieldTo<ISlashCommand>(slashCommands).map((c, i) => {
+					suggestions: slashCommands.map((c, i) => {
 						const withSlash = `/${c.command}`;
 						return <CompletionItem>{
 							label: withSlash,
@@ -354,11 +363,6 @@ class AgentCompletions extends Disposable {
 					return null;
 				}
 
-				if (!model.getValue().trim().match(new RegExp(`^${chatAgentLeader}\\w*$`))) {
-					// Only when the input only contains the start of an agent
-					return;
-				}
-
 				const parsedRequest = (await this.instantiationService.createInstance(ChatRequestParser).parseChatRequest(widget.viewModel.sessionId, model.getValue())).parts;
 				const usedAgent = parsedRequest.find(p => p instanceof ChatRequestAgentPart);
 				if (usedAgent && !Range.containsPosition(usedAgent.editorRange, position)) {
@@ -450,9 +454,9 @@ class AgentCompletions extends Disposable {
 					return;
 				}
 
-				if (!model.getValue().trim().match(new RegExp(`^${chatSubcommandLeader}\\w*$`))) {
-					// Only when the input only contains the start of a slash command
-					return;
+				const range = computeCompletionRanges(model, position, /\/\w*/g);
+				if (!range) {
+					return null;
 				}
 
 				const agents = this.chatAgentService.getAgents();
@@ -463,23 +467,42 @@ class AgentCompletions extends Disposable {
 					return;
 				}
 
-				return <CompletionList>{
-					suggestions: agents.flatMap((agent, i) => commands[i].map((c, i) => {
-						const agentLabel = `@${agent.id}`;
-						const withSlash = `/${c.name}`;
-						return <CompletionItem>{
-							label: { label: withSlash, description: agentLabel },
-							insertText: `${agentLabel} ${withSlash} `,
-							detail: `(${agentLabel}) ${c.description}`,
+				const justAgents: CompletionItem[] = agents
+					.filter(a => !a.metadata.isDefault)
+					.map(agent => {
+						const agentLabel = `${chatAgentLeader}${agent.id}`;
+						return {
+							label: { label: agentLabel, description: agent.metadata.description },
+							filterText: `${chatSubcommandLeader}${agent.id}`,
+							insertText: `${agentLabel} `,
 							range: new Range(1, 1, 1, 1),
-							kind: CompletionItemKind.Text, // The icons are disabled here anyway
+							kind: CompletionItemKind.Text,
+							sortText: `${chatSubcommandLeader}${agent.id}`,
 						};
-					}))
+					});
+
+				return {
+					suggestions: justAgents.concat(
+						agents.flatMap((agent, i) => commands[i].map((c, i) => {
+							const agentLabel = `${chatAgentLeader}${agent.id}`;
+							const withSlash = `${chatSubcommandLeader}${c.name}`;
+							return {
+								label: { label: withSlash, description: agentLabel },
+								filterText: `${chatSubcommandLeader}${agent.id}${c.name}`,
+								commitCharacters: [' '],
+								insertText: `${agentLabel} ${withSlash} `,
+								detail: `(${agentLabel}) ${c.description}`,
+								range: new Range(1, 1, 1, 1),
+								kind: CompletionItemKind.Text, // The icons are disabled here anyway
+								sortText: `${chatSubcommandLeader}${agent.id}${c.name}`,
+							} satisfies CompletionItem;
+						})))
 				};
 			}
 		}));
 	}
 }
+Registry.as<IWorkbenchContributionsRegistry>(WorkbenchExtensions.Workbench).registerWorkbenchContribution(AgentCompletions, LifecyclePhase.Eventually);
 
 class BuiltinDynamicCompletions extends Disposable {
 	private static readonly VariableNameDef = new RegExp(`${chatVariableLeader}\\w*`, 'g'); // MUST be using `g`-flag
@@ -506,31 +529,21 @@ class BuiltinDynamicCompletions extends Disposable {
 					return null;
 				}
 
-				const varWord = getWordAtText(position.column, BuiltinDynamicCompletions.VariableNameDef, model.getLineContent(position.lineNumber), 0);
-				if (!varWord && model.getWordUntilPosition(position).word) {
-					// inside a "normal" word
+				const range = computeCompletionRanges(model, position, BuiltinDynamicCompletions.VariableNameDef);
+				if (!range) {
 					return null;
 				}
 
-				let insert: Range;
-				let replace: Range;
-				if (!varWord) {
-					insert = replace = Range.fromPositions(position);
-				} else {
-					insert = new Range(position.lineNumber, varWord.startColumn, position.lineNumber, position.column);
-					replace = new Range(position.lineNumber, varWord.startColumn, position.lineNumber, varWord.endColumn);
-				}
-
-				const range = new Range(position.lineNumber, replace.startColumn, position.lineNumber, replace.endColumn + 'file:'.length);
+				const afterRange = new Range(position.lineNumber, range.replace.startColumn, position.lineNumber, range.replace.endColumn + 'file:'.length);
 				return <CompletionList>{
 					suggestions: [
 						<CompletionItem>{
 							label: `${chatVariableLeader}file`,
 							insertText: `${chatVariableLeader}file:`,
 							detail: localize('pickFileLabel', "Pick a file"),
-							range: { insert, replace },
+							range,
 							kind: CompletionItemKind.Text,
-							command: { id: SelectAndInsertFileAction.ID, title: SelectAndInsertFileAction.ID, arguments: [{ widget, range }] },
+							command: { id: SelectAndInsertFileAction.ID, title: SelectAndInsertFileAction.ID, arguments: [{ widget, range: afterRange }] },
 							sortText: 'z'
 						}
 					]
@@ -542,82 +555,7 @@ class BuiltinDynamicCompletions extends Disposable {
 
 Registry.as<IWorkbenchContributionsRegistry>(WorkbenchExtensions.Workbench).registerWorkbenchContribution(BuiltinDynamicCompletions, LifecyclePhase.Eventually);
 
-interface SlashCommandYieldTo {
-	command: string;
-}
-
-// Adapted from https://github.com/microsoft/vscode/blob/ca2c1636f87ea4705f32345c2e348e815996e129/src/vs/editor/contrib/dropOrPasteInto/browser/edit.ts#L31-L99
-function sortSlashCommandsByYieldTo<T extends {
-	readonly command: string;
-	readonly yieldsTo?: ReadonlyArray<SlashCommandYieldTo>;
-}>(slashCommands: readonly T[]): T[] {
-	function yieldsTo(yTo: SlashCommandYieldTo, other: T): boolean {
-		return 'command' in yTo && other.command === yTo.command;
-	}
-
-	// Build list of nodes each node yields to
-	const yieldsToMap = new Map<T, T[]>();
-	for (const slashCommand of slashCommands) {
-		for (const yTo of slashCommand.yieldsTo ?? []) {
-			for (const other of slashCommands) {
-				if (other.command === slashCommand.command) {
-					continue;
-				}
-
-				if (yieldsTo(yTo, other)) {
-					let arr = yieldsToMap.get(slashCommand);
-					if (!arr) {
-						arr = [];
-						yieldsToMap.set(slashCommand, arr);
-					}
-					arr.push(other);
-				}
-			}
-		}
-	}
-
-	if (!yieldsToMap.size) {
-		return Array.from(slashCommands);
-	}
-
-	// Topological sort
-	const visited = new Set<T>();
-	const tempStack: T[] = [];
-
-	function visit(nodes: T[]): T[] {
-		if (!nodes.length) {
-			return [];
-		}
-
-		const node = nodes[0];
-		if (tempStack.includes(node)) {
-			console.warn(`Yield to cycle detected for ${node.command}`);
-			return nodes;
-		}
-
-		if (visited.has(node)) {
-			return visit(nodes.slice(1));
-		}
-
-		let pre: T[] = [];
-		const yTo = yieldsToMap.get(node);
-		if (yTo) {
-			tempStack.push(node);
-			pre = visit(yTo);
-			tempStack.pop();
-		}
-
-		visited.add(node);
-
-		return [...pre, node, ...visit(nodes.slice(1))];
-	}
-
-	return visit(Array.from(slashCommands));
-}
-
-Registry.as<IWorkbenchContributionsRegistry>(WorkbenchExtensions.Workbench).registerWorkbenchContribution(AgentCompletions, LifecyclePhase.Eventually);
-
-function computeCompletionRanges(model: ITextModel, position: Position, reg: RegExp): { insert: Range; replace: Range } | undefined {
+function computeCompletionRanges(model: ITextModel, position: Position, reg: RegExp): { insert: Range; replace: Range; varWord: IWordAtPosition | null } | undefined {
 	const varWord = getWordAtText(position.column, reg, model.getLineContent(position.lineNumber), 0);
 	if (!varWord && model.getWordUntilPosition(position).word) {
 		// inside a "normal" word
@@ -633,7 +571,7 @@ function computeCompletionRanges(model: ITextModel, position: Position, reg: Reg
 		replace = new Range(position.lineNumber, varWord.startColumn, position.lineNumber, varWord.endColumn);
 	}
 
-	return { insert, replace };
+	return { insert, replace, varWord };
 }
 
 class VariableCompletions extends Disposable {
diff --git a/src/vs/workbench/contrib/csChat/browser/csChat.ts b/src/vs/workbench/contrib/csChat/browser/csChat.ts
index 3df1e83af19..17d1875bfc4 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChat.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChat.ts
@@ -111,7 +111,7 @@ export interface IChatWidget {
 	focus(item: ChatTreeItem): void;
 	moveFocus(item: ChatTreeItem, type: 'next' | 'previous'): void;
 	getFocus(): ChatTreeItem | undefined;
-	updateInput(query?: string): void;
+	setInput(query?: string): void;
 	getInput(): string;
 	acceptInput(query?: string): void;
 	acceptInputWithPrefix(prefix: string): void;
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatAccessibilityService.ts b/src/vs/workbench/contrib/csChat/browser/csChatAccessibilityService.ts
index 1a19c1d3850..fa522294c26 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatAccessibilityService.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatAccessibilityService.ts
@@ -5,7 +5,7 @@
 
 import { status } from 'vs/base/browser/ui/aria/aria';
 import { RunOnceScheduler } from 'vs/base/common/async';
-import { Disposable, IDisposable } from 'vs/base/common/lifecycle';
+import { Disposable, DisposableMap, IDisposable } from 'vs/base/common/lifecycle';
 import { AudioCue, IAudioCueService } from 'vs/platform/audioCues/browser/audioCueService';
 import { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';
 import { IChatAccessibilityService } from 'vs/workbench/contrib/chat/browser/chat';
@@ -15,7 +15,7 @@ export class ChatAccessibilityService extends Disposable implements IChatAccessi
 
 	declare readonly _serviceBrand: undefined;
 
-	private _pendingCueMap: Map<number, AudioCueScheduler> = new Map();
+	private _pendingCueMap: DisposableMap<number, AudioCueScheduler> = this._register(new DisposableMap());
 
 	private _requestId: number = 0;
 
@@ -25,12 +25,11 @@ export class ChatAccessibilityService extends Disposable implements IChatAccessi
 	acceptRequest(): number {
 		this._requestId++;
 		this._audioCueService.playAudioCue(AudioCue.chatRequestSent, { allowManyInParallel: true });
-		this._pendingCueMap.set(this._requestId, this._register(this._instantiationService.createInstance(AudioCueScheduler)));
+		this._pendingCueMap.set(this._requestId, this._instantiationService.createInstance(AudioCueScheduler));
 		return this._requestId;
 	}
 	acceptResponse(response: IChatResponseViewModel | string | undefined, requestId: number): void {
-		this._pendingCueMap.get(requestId)?.dispose();
-		this._pendingCueMap.delete(requestId);
+		this._pendingCueMap.deleteAndDispose(requestId);
 		const isPanelChat = typeof response !== 'string';
 		const responseContent = typeof response === 'string' ? response : response?.response.asString();
 		this._audioCueService.playAudioCue(AudioCue.chatResponseReceived, { allowManyInParallel: true });
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatEditor.ts b/src/vs/workbench/contrib/csChat/browser/csChatEditor.ts
index 9954e4fba4f..ee8045df6c3 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatEditor.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatEditor.ts
@@ -3,7 +3,6 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 
-import 'vs/css!./media/chatEditor';
 import * as dom from 'vs/base/browser/dom';
 import { CancellationToken } from 'vs/base/common/cancellation';
 import { IContextKeyService, IScopedContextKeyService } from 'vs/platform/contextkey/common/contextkey';
@@ -18,7 +17,7 @@ import { EditorPane } from 'vs/workbench/browser/parts/editor/editorPane';
 import { IEditorOpenContext } from 'vs/workbench/common/editor';
 import { Memento } from 'vs/workbench/common/memento';
 import { ChatEditorInput } from 'vs/workbench/contrib/chat/browser/chatEditorInput';
-import { IViewState, ChatWidget } from 'vs/workbench/contrib/chat/browser/chatWidget';
+import { IChatViewState, ChatWidget } from 'vs/workbench/contrib/chat/browser/chatWidget';
 import { IChatModel, ISerializableChatData } from 'vs/workbench/contrib/chat/common/chatModel';
 import { clearChatEditor } from 'vs/workbench/contrib/chat/browser/actions/chatClear';
 
@@ -35,7 +34,7 @@ export class ChatEditor extends EditorPane {
 	}
 
 	private _memento: Memento | undefined;
-	private _viewState: IViewState | undefined;
+	private _viewState: IChatViewState | undefined;
 
 	constructor(
 		@ITelemetryService telemetryService: ITelemetryService,
@@ -99,7 +98,7 @@ export class ChatEditor extends EditorPane {
 
 	private updateModel(model: IChatModel): void {
 		this._memento = new Memento('interactive-session-editor-' + model.sessionId, this.storageService);
-		this._viewState = this._memento.getMemento(StorageScope.WORKSPACE, StorageTarget.MACHINE) as IViewState;
+		this._viewState = this._memento.getMemento(StorageScope.WORKSPACE, StorageTarget.MACHINE) as IChatViewState;
 		this.widget.setModel(model, { ...this._viewState });
 	}
 
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatEditorInput.ts b/src/vs/workbench/contrib/csChat/browser/csChatEditorInput.ts
index ed7152d1d44..f59f81e2ffb 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatEditorInput.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatEditorInput.ts
@@ -4,18 +4,23 @@
  *--------------------------------------------------------------------------------------------*/
 
 import { CancellationToken } from 'vs/base/common/cancellation';
+import { Codicon } from 'vs/base/common/codicons';
 import { Emitter } from 'vs/base/common/event';
 import { Disposable, toDisposable } from 'vs/base/common/lifecycle';
 import { Schemas } from 'vs/base/common/network';
+import { ThemeIcon } from 'vs/base/common/themables';
 import { URI } from 'vs/base/common/uri';
 import * as nls from 'vs/nls';
 import { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';
+import { registerIcon } from 'vs/platform/theme/common/iconRegistry';
 import { EditorInputCapabilities, IEditorSerializer, IUntypedEditorInput } from 'vs/workbench/common/editor';
 import { EditorInput } from 'vs/workbench/common/editor/editorInput';
 import type { IChatEditorOptions } from 'vs/workbench/contrib/chat/browser/chatEditor';
 import { IChatModel } from 'vs/workbench/contrib/chat/common/chatModel';
 import { IChatService } from 'vs/workbench/contrib/chat/common/chatService';
 
+const ChatEditorIcon = registerIcon('chat-editor-label-icon', Codicon.commentDiscussion, nls.localize('chatEditorLabelIcon', 'Icon of the chat editor label.'));
+
 export class ChatEditorInput extends EditorInput {
 	static readonly countsInUse = new Set<number>();
 
@@ -81,8 +86,8 @@ export class ChatEditorInput extends EditorInput {
 		return this.model?.title || nls.localize('chatEditorName', "Chat") + (this.inputCount > 0 ? ` ${this.inputCount + 1}` : '');
 	}
 
-	override getLabelExtraClasses(): string[] {
-		return ['chat-editor-label'];
+	override getIcon(): ThemeIcon {
+		return ChatEditorIcon;
 	}
 
 	override async resolve(): Promise<ChatEditorModel | null> {
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatInputPart.ts b/src/vs/workbench/contrib/csChat/browser/csChatInputPart.ts
index eb115500062..68d027868f2 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatInputPart.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatInputPart.ts
@@ -5,15 +5,21 @@
 
 import * as dom from 'vs/base/browser/dom';
 import { IHistoryNavigationWidget } from 'vs/base/browser/history';
+import { ActionViewItem, IActionViewItemOptions } from 'vs/base/browser/ui/actionbar/actionViewItems';
 import * as aria from 'vs/base/browser/ui/aria/aria';
+import { IAction } from 'vs/base/common/actions';
 import { Emitter } from 'vs/base/common/event';
 import { HistoryNavigator } from 'vs/base/common/history';
 import { Disposable, DisposableStore } from 'vs/base/common/lifecycle';
+import { isMacintosh } from 'vs/base/common/platform';
 import { URI } from 'vs/base/common/uri';
+import { EditorExtensionsRegistry } from 'vs/editor/browser/editorExtensions';
 import { CodeEditorWidget } from 'vs/editor/browser/widget/codeEditorWidget';
 import { ITextModel } from 'vs/editor/common/model';
 import { IModelService } from 'vs/editor/common/services/model';
+import { HoverController } from 'vs/editor/contrib/hover/browser/hover';
 import { localize } from 'vs/nls';
+import { IAccessibilityService } from 'vs/platform/accessibility/common/accessibility';
 import { MenuWorkbenchToolBar } from 'vs/platform/actions/browser/toolbar';
 import { MenuId } from 'vs/platform/actions/common/actions';
 import { IConfigurationService } from 'vs/platform/configuration/common/configuration';
@@ -23,20 +29,20 @@ import { IInstantiationService } from 'vs/platform/instantiation/common/instanti
 import { ServiceCollection } from 'vs/platform/instantiation/common/serviceCollection';
 import { IKeybindingService } from 'vs/platform/keybinding/common/keybinding';
 import { DEFAULT_FONT_FAMILY } from 'vs/workbench/browser/style';
-import { getSimpleCodeEditorWidgetOptions, getSimpleEditorOptions } from 'vs/workbench/contrib/codeEditor/browser/simpleEditorOptions';
-import { IChatExecuteActionContext } from 'vs/workbench/contrib/chat/browser/actions/chatExecuteActions';
+import { AccessibilityVerbositySettingId } from 'vs/workbench/contrib/accessibility/browser/accessibilityConfiguration';
+import { AccessibilityCommandId } from 'vs/workbench/contrib/accessibility/common/accessibilityCommands';
+import { IChatExecuteActionContext, SubmitAction } from 'vs/workbench/contrib/chat/browser/actions/chatExecuteActions';
 import { IChatWidget } from 'vs/workbench/contrib/chat/browser/chat';
 import { ChatFollowups } from 'vs/workbench/contrib/chat/browser/chatFollowups';
-import { CONTEXT_CHAT_INPUT_HAS_TEXT, CONTEXT_IN_CHAT_INPUT } from 'vs/workbench/contrib/chat/common/chatContextKeys';
+import { IChatAgentService } from 'vs/workbench/contrib/chat/common/chatAgents';
+import { CONTEXT_CHAT_INPUT_CURSOR_AT_TOP, CONTEXT_CHAT_INPUT_HAS_TEXT, CONTEXT_IN_CHAT_INPUT } from 'vs/workbench/contrib/chat/common/chatContextKeys';
+import { chatAgentLeader } from 'vs/workbench/contrib/chat/common/chatParserTypes';
 import { IChatReplyFollowup } from 'vs/workbench/contrib/chat/common/chatService';
-import { IChatWidgetHistoryService } from 'vs/workbench/contrib/chat/common/chatWidgetHistoryService';
-import { AccessibilityVerbositySettingId } from 'vs/workbench/contrib/accessibility/browser/accessibilityConfiguration';
-import { IAccessibilityService } from 'vs/platform/accessibility/common/accessibility';
-import { isMacintosh } from 'vs/base/common/platform';
-import { AccessibilityCommandId } from 'vs/workbench/contrib/accessibility/common/accessibilityCommands';
-import { ModesHoverController } from 'vs/editor/contrib/hover/browser/hover';
-import { EditorExtensionsRegistry } from 'vs/editor/browser/editorExtensions';
 import { IChatResponseViewModel } from 'vs/workbench/contrib/chat/common/chatViewModel';
+import { IChatWidgetHistoryService } from 'vs/workbench/contrib/chat/common/chatWidgetHistoryService';
+import { getSimpleCodeEditorWidgetOptions, getSimpleEditorOptions } from 'vs/workbench/contrib/codeEditor/browser/simpleEditorOptions';
+import { ChatSubmitEditorAction, ChatSubmitSecondaryAgentEditorAction } from 'vs/workbench/contrib/chat/browser/actions/chatActions';
+import { IPosition } from 'vs/editor/common/core/position';
 
 const $ = dom.$;
 
@@ -46,6 +52,9 @@ export class ChatInputPart extends Disposable implements IHistoryNavigationWidge
 	static readonly INPUT_SCHEME = 'chatSessionInput';
 	private static _counter = 0;
 
+	private _onDidLoadInputState = this._register(new Emitter<any>());
+	readonly onDidLoadInputState = this._onDidLoadInputState.event;
+
 	private _onDidChangeHeight = this._register(new Emitter<void>());
 	readonly onDidChangeHeight = this._onDidChangeHeight.event;
 
@@ -74,9 +83,12 @@ export class ChatInputPart extends Disposable implements IHistoryNavigationWidge
 	}
 
 	private history: HistoryNavigator<string>;
-	private setHistoryNavigationEnablement!: (enabled: boolean) => void;
+	private historyStates: Map<string, any> = new Map();
+	private historyNavigationBackwardsEnablement!: IContextKey<boolean>;
+	private historyNavigationForewardsEnablement!: IContextKey<boolean>;
 	private inputModel: ITextModel | undefined;
 	private inputEditorHasText: IContextKey<boolean>;
+	private chatCursorAtTop: IContextKey<boolean>;
 	private providerId: string | undefined;
 
 	private cachedDimensions: dom.Dimension | undefined;
@@ -98,6 +110,8 @@ export class ChatInputPart extends Disposable implements IHistoryNavigationWidge
 		super();
 
 		this.inputEditorHasText = CONTEXT_CHAT_INPUT_HAS_TEXT.bindTo(contextKeyService);
+		this.chatCursorAtTop = CONTEXT_CHAT_INPUT_CURSOR_AT_TOP.bindTo(contextKeyService);
+
 		this.history = new HistoryNavigator([], 5);
 		this._register(this.historyService.onDidClearHistory(() => this.history.clear()));
 		this._register(this.configurationService.onDidChangeConfiguration(e => {
@@ -119,7 +133,11 @@ export class ChatInputPart extends Disposable implements IHistoryNavigationWidge
 	setState(providerId: string, inputValue: string | undefined): void {
 		this.providerId = providerId;
 		const history = this.historyService.getHistory(providerId);
-		this.history = new HistoryNavigator(history, 50);
+		this.historyStates = new Map(history.map(h => [h.text, h.state]));
+		const historyTexts: string[] = [];
+		this.historyStates.forEach((_, str) => historyTexts.push(str));
+
+		this.history = new HistoryNavigator(historyTexts, 50);
 
 		if (typeof inputValue === 'string') {
 			this.setValue(inputValue);
@@ -145,7 +163,17 @@ export class ChatInputPart extends Disposable implements IHistoryNavigationWidge
 
 		aria.status(historyInput);
 		this.setValue(historyInput);
-		this.setHistoryNavigationEnablement(true);
+		this._onDidLoadInputState.fire(this.historyStates.get(historyInput));
+		if (previous) {
+			this._inputEditor.setPosition({ lineNumber: 1, column: 1 });
+		} else {
+			const model = this._inputEditor.getModel();
+			if (!model) {
+				return;
+			}
+
+			this._inputEditor.setPosition(getLastPosition(model));
+		}
 	}
 
 	setValue(value: string): void {
@@ -166,9 +194,10 @@ export class ChatInputPart extends Disposable implements IHistoryNavigationWidge
 	 * Reset the input and update history.
 	 * @param userQuery If provided, this will be added to the history. Followups and programmatic queries should not be passed.
 	 */
-	async acceptInput(userQuery?: string): Promise<void> {
+	async acceptInput(userQuery?: string, inputState?: any): Promise<void> {
 		if (userQuery) {
 			this.history.add(userQuery);
+			this.historyStates.set(userQuery, inputState);
 		}
 
 		if (this.accessibilityService.isScreenReaderOptimized() && isMacintosh) {
@@ -204,10 +233,8 @@ export class ChatInputPart extends Disposable implements IHistoryNavigationWidge
 		const scopedInstantiationService = this.instantiationService.createChild(new ServiceCollection([IContextKeyService, inputScopedContextKeyService]));
 
 		const { historyNavigationBackwardsEnablement, historyNavigationForwardsEnablement } = this._register(registerAndCreateHistoryNavigationContext(inputScopedContextKeyService, this));
-		this.setHistoryNavigationEnablement = enabled => {
-			historyNavigationBackwardsEnablement.set(enabled);
-			historyNavigationForwardsEnablement.set(enabled);
-		};
+		this.historyNavigationBackwardsEnablement = historyNavigationBackwardsEnablement;
+		this.historyNavigationForewardsEnablement = historyNavigationForwardsEnablement;
 
 		const options = getSimpleEditorOptions(this.configurationService);
 		options.readOnly = false;
@@ -219,12 +246,17 @@ export class ChatInputPart extends Disposable implements IHistoryNavigationWidge
 		options.cursorWidth = 1;
 		options.wrappingStrategy = 'advanced';
 		options.bracketPairColorization = { enabled: false };
-		options.suggest = { showIcons: false };
+		options.suggest = {
+			showIcons: false,
+			showSnippets: false,
+			showWords: true,
+			showStatusBar: false,
+		};
 		options.scrollbar = { ...(options.scrollbar ?? {}), vertical: 'hidden' };
 
 		this._inputEditorElement = dom.append(inputContainer, $('.interactive-input-editor'));
 		const editorOptions = getSimpleCodeEditorWidgetOptions();
-		editorOptions.contributions?.push(...EditorExtensionsRegistry.getSomeEditorContributions([ModesHoverController.ID]));
+		editorOptions.contributions?.push(...EditorExtensionsRegistry.getSomeEditorContributions([HoverController.ID]));
 		this._inputEditor = this._register(scopedInstantiationService.createInstance(CodeEditorWidget, this._inputEditorElement, options, editorOptions));
 
 		this._register(this._inputEditor.onDidChangeModelContent(() => {
@@ -238,7 +270,6 @@ export class ChatInputPart extends Disposable implements IHistoryNavigationWidge
 			// (If this model change happened as a result of a history navigation, this is canceled out by a call in this.navigateHistory)
 			const model = this._inputEditor.getModel();
 			const inputHasText = !!model && model.getValueLength() > 0;
-			this.setHistoryNavigationEnablement(!inputHasText);
 			this.inputEditorHasText.set(inputHasText);
 		}));
 		this._register(this._inputEditor.onDidFocusEditorText(() => {
@@ -250,14 +281,32 @@ export class ChatInputPart extends Disposable implements IHistoryNavigationWidge
 
 			this._onDidBlur.fire();
 		}));
+		this._register(this._inputEditor.onDidChangeCursorPosition(e => {
+			const model = this._inputEditor.getModel();
+			if (!model) {
+				return;
+			}
+
+			const atTop = e.position.column === 1 && e.position.lineNumber === 1;
+			this.historyNavigationBackwardsEnablement.set(atTop);
+			this.chatCursorAtTop.set(atTop);
+			this.historyNavigationForewardsEnablement.set(e.position.equals(getLastPosition(model)));
+		}));
 
 		this.toolbar = this._register(this.instantiationService.createInstance(MenuWorkbenchToolBar, inputContainer, MenuId.ChatExecute, {
 			menuOptions: {
 				shouldForwardArgs: true
+			},
+			actionViewItemProvider: (action, options) => {
+				if (action.id === SubmitAction.ID) {
+					return this.instantiationService.createInstance(SubmitButtonActionViewItem, { widget } satisfies IChatExecuteActionContext, action, options);
+				}
+
+				return undefined;
 			}
 		}));
 		this.toolbar.getElement().classList.add('interactive-execute-toolbar');
-		this.toolbar.context = <IChatExecuteActionContext>{ widget };
+		this.toolbar.context = { widget } satisfies IChatExecuteActionContext;
 		this._register(this.toolbar.onDidChangeMenuItems(() => {
 			if (this.cachedDimensions && typeof this.cachedToolbarWidth === 'number' && this.cachedToolbarWidth !== this.toolbar.getItemsWidth()) {
 				this.layout(this.cachedDimensions.height, this.cachedDimensions.width);
@@ -271,7 +320,7 @@ export class ChatInputPart extends Disposable implements IHistoryNavigationWidge
 				}
 			}));
 			toolbarSide.getElement().classList.add('chat-side-toolbar');
-			toolbarSide.context = <IChatExecuteActionContext>{ widget };
+			toolbarSide.context = { widget } satisfies IChatExecuteActionContext;
 		}
 
 		this.inputModel = this.modelService.getModel(this.inputUri) || this.modelService.createModel('', null, this.inputUri, true);
@@ -331,6 +380,45 @@ export class ChatInputPart extends Disposable implements IHistoryNavigationWidge
 
 	saveState(): void {
 		const inputHistory = this.history.getHistory();
-		this.historyService.saveHistory(this.providerId!, inputHistory);
+		const historyEntries = inputHistory.map(entry => ({ text: entry, state: this.historyStates.get(entry) }));
+		this.historyService.saveHistory(this.providerId!, historyEntries);
 	}
 }
+
+class SubmitButtonActionViewItem extends ActionViewItem {
+	private readonly _tooltip: string;
+
+	constructor(
+		context: unknown,
+		action: IAction,
+		options: IActionViewItemOptions,
+		@IKeybindingService keybindingService: IKeybindingService,
+		@IChatAgentService chatAgentService: IChatAgentService,
+	) {
+		super(context, action, options);
+
+		const primaryKeybinding = keybindingService.lookupKeybinding(ChatSubmitEditorAction.ID)?.getLabel();
+		let tooltip = action.label;
+		if (primaryKeybinding) {
+			tooltip += ` (${primaryKeybinding})`;
+		}
+
+		const secondaryAgent = chatAgentService.getSecondaryAgent();
+		if (secondaryAgent) {
+			const secondaryKeybinding = keybindingService.lookupKeybinding(ChatSubmitSecondaryAgentEditorAction.ID)?.getLabel();
+			if (secondaryKeybinding) {
+				tooltip += `\n${chatAgentLeader}${secondaryAgent.id} (${secondaryKeybinding})`;
+			}
+		}
+
+		this._tooltip = tooltip;
+	}
+
+	protected override getTooltip(): string | undefined {
+		return this._tooltip;
+	}
+}
+
+function getLastPosition(model: ITextModel): IPosition {
+	return { lineNumber: model.getLineCount(), column: model.getLineLength(model.getLineCount()) + 1 };
+}
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatListRenderer.ts b/src/vs/workbench/contrib/csChat/browser/csChatListRenderer.ts
index dac8c2a0423..66afb5bfef3 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatListRenderer.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatListRenderer.ts
@@ -25,6 +25,7 @@ import { Disposable, DisposableStore, IDisposable, toDisposable } from 'vs/base/
 import { ResourceMap } from 'vs/base/common/map';
 import { marked } from 'vs/base/common/marked/marked';
 import { FileAccess } from 'vs/base/common/network';
+import { clamp } from 'vs/base/common/numbers';
 import { ThemeIcon } from 'vs/base/common/themables';
 import { URI } from 'vs/base/common/uri';
 import { IMarkdownRenderResult, MarkdownRenderer } from 'vs/editor/contrib/markdownRenderer/browser/markdownRenderer';
@@ -35,9 +36,10 @@ import { MenuId, MenuItemAction } from 'vs/platform/actions/common/actions';
 import { ICommandService } from 'vs/platform/commands/common/commands';
 import { IConfigurationService } from 'vs/platform/configuration/common/configuration';
 import { IContextKeyService } from 'vs/platform/contextkey/common/contextkey';
-import { FileKind } from 'vs/platform/files/common/files';
+import { FileKind, FileType } from 'vs/platform/files/common/files';
 import { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';
 import { ServiceCollection } from 'vs/platform/instantiation/common/serviceCollection';
+import { IKeybindingService } from 'vs/platform/keybinding/common/keybinding';
 import { WorkbenchCompressibleAsyncDataTree, WorkbenchList } from 'vs/platform/list/browser/listService';
 import { ILogService } from 'vs/platform/log/common/log';
 import { IOpenerService } from 'vs/platform/opener/common/opener';
@@ -139,6 +141,7 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 		@IEditorService private readonly editorService: IEditorService,
 		@IProductService productService: IProductService,
 		@IThemeService private readonly themeService: IThemeService,
+		@IKeybindingService private readonly keybindingService: IKeybindingService,
 	) {
 		super();
 		this.renderer = this.instantiationService.createInstance(MarkdownRenderer, {});
@@ -168,17 +171,20 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 
 	private getProgressiveRenderRate(element: IChatResponseViewModel): number {
 		if (element.isComplete) {
-			return 60;
+			return 80;
 		}
 
 		if (element.contentUpdateTimings && element.contentUpdateTimings.impliedWordLoadRate) {
+			// words/s
 			const minRate = 12;
+			const maxRate = 80;
+
 			// This doesn't account for dead time after the last update. When the previous update is the final one and the model is only waiting for followupQuestions, that's good.
 			// When there was one quick update and then you are waiting longer for the next one, that's not good since the rate should be decreasing.
 			// If it's an issue, we can change this to be based on the total time from now to the beginning.
 			const rateBoost = 1.5;
 			const rate = element.contentUpdateTimings.impliedWordLoadRate * rateBoost;
-			return Math.max(rate, minRate);
+			return clamp(rate, minRate, maxRate);
 		}
 
 		return 8;
@@ -294,13 +300,14 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 		templateData.rowContainer.classList.toggle('interactive-response', isResponseVM(element));
 		templateData.rowContainer.classList.toggle('interactive-welcome', isWelcomeVM(element));
 		templateData.rowContainer.classList.toggle('filtered-response', isFiltered);
-		templateData.rowContainer.classList.toggle('show-progress', isResponseVM(element) && !element.isComplete);
+		templateData.rowContainer.classList.toggle('show-detail-progress', isResponseVM(element) && !element.isComplete && !element.progressMessages.length);
 		templateData.username.textContent = element.username;
 		if (!this.rendererOptions.noHeader) {
 			this.renderAvatar(element, templateData);
 		}
 
 		dom.clearNode(templateData.detail);
+		dom.clearNode(templateData.progressSteps);
 		if (isResponseVM(element)) {
 			this.renderDetail(element, templateData);
 			this.renderProgressSteps(element, templateData);
@@ -369,8 +376,7 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 	}
 
 	private renderProgressSteps(element: IChatResponseViewModel, templateData: IChatListItemTemplate): void {
-		dom.clearNode(templateData.progressSteps);
-		if (element.response.value.length) {
+		if (element.response.value.length || element.isComplete) {
 			return;
 		}
 
@@ -550,6 +556,7 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 			const wordCountResults: IWordCountResult[] = [];
 			const partsToRender: IChatResponseRenderData['renderedParts'] = [];
 
+			let somePartIsNotFullyRendered = false;
 			renderableResponse.forEach((part, index) => {
 				const renderedPart = renderedParts[index];
 				// Is this part completely new?
@@ -559,6 +566,7 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 					} else {
 						const wordCountResult = this.getDataForProgressiveRender(element, contentToMarkdown(part.content), { renderedWordCount: 0, lastRenderTime: 0 });
 						if (wordCountResult !== undefined) {
+							this.traceLayout('doNextProgressiveRender', `Rendering new part ${index}, wordCountResult=${wordCountResult.actualWordCount}, rate=${wordCountResult.rate}`);
 							partsToRender[index] = {
 								renderedWordCount: wordCountResult.actualWordCount,
 								lastRenderTime: Date.now(),
@@ -579,17 +587,21 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 					const wordCountResult = this.getDataForProgressiveRender(element, contentToMarkdown(part.content), renderedPart);
 					// Check if there are any new words to render
 					if (wordCountResult !== undefined && renderedPart.renderedWordCount !== wordCountResult?.actualWordCount) {
+						this.traceLayout('doNextProgressiveRender', `Rendering changed part ${index}, wordCountResult=${wordCountResult.actualWordCount}, rate=${wordCountResult.rate}`);
 						partsToRender[index] = {
 							renderedWordCount: wordCountResult.actualWordCount,
 							lastRenderTime: Date.now(),
 							isFullyRendered: wordCountResult.isFullString,
 						};
 						wordCountResults[index] = wordCountResult;
+					} else if (!renderedPart.isFullyRendered && !wordCountResult) {
+						// This part is not fully rendered, but not enough time has passed to render more content
+						somePartIsNotFullyRendered = true;
 					}
 				}
 			});
 
-			isFullyRendered = partsToRender.length === 0;
+			isFullyRendered = partsToRender.length === 0 && !somePartIsNotFullyRendered;
 
 			if (isFullyRendered && element.isComplete) {
 				// Response is done and content is rendered, so do a normal render
@@ -845,7 +857,7 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 				orderedDisposablesList.push(ref);
 				return ref.object.element;
 			},
-			asyncRenderCallback: () => this._onDidChangeItemHeight.fire({ element, height: templateData.rowContainer.offsetHeight })
+			asyncRenderCallback: () => this._onDidChangeItemHeight.fire({ element, height: templateData.rowContainer.offsetHeight }),
 		});
 
 		if (isResponseVM(element)) {
@@ -853,7 +865,7 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 			disposables.add(toDisposable(() => this.codeBlocksByResponseId.delete(element.id)));
 		}
 
-		walkTreeAndAnnotateReferenceLinks(result.element);
+		walkTreeAndAnnotateReferenceLinks(result.element, this.keybindingService);
 
 		orderedDisposablesList.reverse().forEach(d => disposables.add(d));
 		return {
@@ -873,7 +885,7 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 		return ref;
 	}
 
-	private getDataForProgressiveRender(element: IChatResponseViewModel, data: IMarkdownString, renderData: Pick<IChatResponseMarkdownRenderData, 'lastRenderTime' | 'renderedWordCount'>): IWordCountResult | undefined {
+	private getDataForProgressiveRender(element: IChatResponseViewModel, data: IMarkdownString, renderData: Pick<IChatResponseMarkdownRenderData, 'lastRenderTime' | 'renderedWordCount'>): IWordCountResult & { rate: number } | undefined {
 		const rate = this.getProgressiveRenderRate(element);
 		const numWordsToRender = renderData.lastRenderTime === 0 ?
 			1 :
@@ -885,7 +897,10 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 			return undefined;
 		}
 
-		return getNWords(data.value, numWordsToRender);
+		return {
+			...getNWords(data.value, numWordsToRender),
+			rate
+		};
 	}
 
 	disposeElement(node: ITreeNode<ChatTreeItem, FuzzyScore>, index: number, templateData: IChatListItemTemplate): void {
@@ -1280,8 +1295,7 @@ class ChatListTreeRenderer implements ICompressibleTreeRenderer<IChatResponsePro
 	}
 	renderElement(element: ITreeNode<IChatResponseProgressFileTreeData, void>, index: number, templateData: IChatListTreeRendererTemplate, height: number | undefined): void {
 		templateData.label.element.style.display = 'flex';
-		const hasExtension = /\.[^/.]+$/.test(element.element.label);
-		if (!element.children.length && hasExtension) {
+		if (!element.children.length && element.element.type !== FileType.Directory) {
 			templateData.label.setFile(element.element.uri, {
 				fileKind: FileKind.FILE,
 				hidePath: true,
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatMarkdownDecorationsRenderer.ts b/src/vs/workbench/contrib/csChat/browser/csChatMarkdownDecorationsRenderer.ts
index b630cba32d2..8c449efcafe 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatMarkdownDecorationsRenderer.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatMarkdownDecorationsRenderer.ts
@@ -10,9 +10,10 @@ import { basename } from 'vs/base/common/resources';
 import { URI } from 'vs/base/common/uri';
 import { IRange } from 'vs/editor/common/core/range';
 import { Location } from 'vs/editor/common/languages';
+import { IKeybindingService } from 'vs/platform/keybinding/common/keybinding';
 import { IChatProgressRenderableResponseContent, IChatProgressResponseContent } from 'vs/workbench/contrib/chat/common/chatModel';
 import { ChatRequestTextPart, IParsedChatRequest } from 'vs/workbench/contrib/chat/common/chatParserTypes';
-import { IChatAgentMarkdownContentWithVulnerability, IChatContentInlineReference } from 'vs/workbench/contrib/chat/common/chatService';
+import { IChatAgentMarkdownContentWithVulnerability, IChatAgentVulnerabilityDetails, IChatContentInlineReference } from 'vs/workbench/contrib/chat/common/chatService';
 
 const variableRefUrl = 'http://_vscodedecoration_';
 
@@ -29,7 +30,7 @@ export function convertParsedRequestToMarkdown(parsedRequest: IParsedChatRequest
 	return result;
 }
 
-export function walkTreeAndAnnotateReferenceLinks(element: HTMLElement): void {
+export function walkTreeAndAnnotateReferenceLinks(element: HTMLElement, keybindingService: IKeybindingService): void {
 	element.querySelectorAll('a').forEach(a => {
 		const href = a.getAttribute('data-href');
 		if (href) {
@@ -39,11 +40,26 @@ export function walkTreeAndAnnotateReferenceLinks(element: HTMLElement): void {
 					a);
 			} else if (href.startsWith(contentRefUrl)) {
 				renderFileWidget(href, a);
+			} else if (href.startsWith('command:')) {
+				injectKeybindingHint(a, href, keybindingService);
 			}
 		}
 	});
 }
 
+function injectKeybindingHint(a: HTMLAnchorElement, href: string, keybindingService: IKeybindingService): void {
+	const command = href.match(/command:([^\)]+)/)?.[1];
+	if (command) {
+		const kb = keybindingService.lookupKeybinding(command);
+		if (kb) {
+			const keybinding = kb.getLabel();
+			if (keybinding) {
+				a.textContent = `${a.textContent} (${keybinding})`;
+			}
+		}
+	}
+}
+
 function renderResourceWidget(name: string): HTMLElement {
 	const container = dom.$('span.chat-resource-widget');
 	const alias = dom.$('span', undefined, name);
@@ -69,8 +85,8 @@ export function extractVulnerabilitiesFromText(text: string): { newText: string;
 	const vulnerabilities: IMarkdownVulnerability[] = [];
 	let newText = text;
 	let match: RegExpExecArray | null;
-	while ((match = /<vscode_annotation title="(.*?)" description="(.*?)">(.*?)<\/vscode_annotation>/ms.exec(newText)) !== null) {
-		const [full, title, description, content] = match;
+	while ((match = /<vscode_annotation details="(.*?)">(.*?)<\/vscode_annotation>/ms.exec(newText)) !== null) {
+		const [full, details, content] = match;
 		const start = match.index;
 		const textBefore = newText.substring(0, start);
 		const linesBefore = textBefore.split('\n').length - 1;
@@ -81,7 +97,16 @@ export function extractVulnerabilitiesFromText(text: string): { newText: string;
 		const endPreviousNewlineIdx = (textBefore + content).lastIndexOf('\n');
 		const endColumn = start + content.length - (endPreviousNewlineIdx + 1) + 1;
 
-		vulnerabilities.push({ title: decodeURIComponent(title), description: decodeURIComponent(description), range: { startLineNumber: linesBefore + 1, startColumn, endLineNumber: linesBefore + linesInside + 1, endColumn } });
+		try {
+			const vulnDetails: IChatAgentVulnerabilityDetails[] = JSON.parse(decodeURIComponent(details));
+			vulnDetails.forEach(({ title, description }) =>
+				vulnerabilities.push({
+					title, description, range:
+						{ startLineNumber: linesBefore + 1, startColumn, endLineNumber: linesBefore + linesInside + 1, endColumn }
+				}));
+		} catch (err) {
+			// Something went wrong with encoding this text, just ignore it
+		}
 		newText = newText.substring(0, start) + content + newText.substring(start + full.length);
 	}
 
@@ -106,7 +131,8 @@ export function annotateSpecialMarkdownContent(response: ReadonlyArray<IChatProg
 		} else if (item.kind === 'markdownContent' && previousItem?.kind === 'markdownContent') {
 			result[result.length - 1] = { content: new MarkdownString(previousItem.content.value + item.content.value, { isTrusted: previousItem.content.isTrusted }), kind: 'markdownContent' };
 		} else if (item.kind === 'markdownVuln') {
-			const markdownText = `<vscode_annotation title="${encodeURIComponent(item.title)}" description="${encodeURIComponent(item.description)}">${item.content.value}</vscode_annotation>`;
+			const vulnText = encodeURIComponent(JSON.stringify(item.vulnerabilities));
+			const markdownText = `<vscode_annotation details="${vulnText}">${item.content.value}</vscode_annotation>`;
 			if (previousItem?.kind === 'markdownContent') {
 				result[result.length - 1] = { content: new MarkdownString(previousItem.content.value + markdownText, { isTrusted: previousItem.content.isTrusted }), kind: 'markdownContent' };
 			} else {
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatSlashCommandContentWidget.ts b/src/vs/workbench/contrib/csChat/browser/csChatSlashCommandContentWidget.ts
index 8a18c809f96..39aa0aafad3 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatSlashCommandContentWidget.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatSlashCommandContentWidget.ts
@@ -11,6 +11,7 @@ import { ContentWidgetPositionPreference, ICodeEditor, IContentWidget } from 'vs
 import { KeyCode } from 'vs/base/common/keyCodes';
 import { localize } from 'vs/nls';
 import * as aria from 'vs/base/browser/ui/aria/aria';
+import { EditorOption } from 'vs/editor/common/config/editorOptions';
 
 export class SlashCommandContentWidget extends Disposable implements IContentWidget {
 	private _domNode = document.createElement('div');
@@ -28,23 +29,24 @@ export class SlashCommandContentWidget extends Disposable implements IContentWid
 	}
 
 	override dispose() {
-		this._editor.removeContentWidget(this);
+		this.hide();
 		super.dispose();
 	}
 
 	show() {
-		if (this._isVisible) {
-			return;
+		if (!this._isVisible) {
+			this._isVisible = true;
+			this._domNode.toggleAttribute('hidden', false);
+			this._editor.addContentWidget(this);
 		}
-		this._isVisible = true;
-		this._domNode.toggleAttribute('hidden', false);
-		this._editor.addContentWidget(this);
 	}
 
 	hide() {
-		this._isVisible = false;
-		this._domNode.toggleAttribute('hidden', true);
-		this._editor.removeContentWidget(this);
+		if (this._isVisible) {
+			this._isVisible = false;
+			this._domNode.toggleAttribute('hidden', true);
+			this._editor.removeContentWidget(this);
+		}
 	}
 
 	setCommandText(slashCommand: string) {
@@ -52,9 +54,23 @@ export class SlashCommandContentWidget extends Disposable implements IContentWid
 		this._lastSlashCommandText = slashCommand;
 	}
 
-	getId() { return 'chat-slash-command-content-widget'; }
-	getDomNode() { return this._domNode; }
-	getPosition() { return { position: { lineNumber: 1, column: 1 }, preference: [ContentWidgetPositionPreference.EXACT] }; }
+	getId() {
+		return 'chat-slash-command-content-widget';
+	}
+
+	getDomNode() {
+		return this._domNode;
+	}
+
+	getPosition() {
+		return { position: { lineNumber: 1, column: 1 }, preference: [ContentWidgetPositionPreference.EXACT] };
+	}
+
+	beforeRender(): null {
+		const lineHeight = this._editor.getOption(EditorOption.lineHeight);
+		this._domNode.style.lineHeight = `${lineHeight - 2 /*padding*/}px`;
+		return null;
+	}
 
 	private _handleKeyDown(e: IKeyboardEvent) {
 		if (e.keyCode !== KeyCode.Backspace) {
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatVariables.ts b/src/vs/workbench/contrib/csChat/browser/csChatVariables.ts
index 90ed4ac45b3..578d5369667 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatVariables.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatVariables.ts
@@ -8,10 +8,10 @@ import { onUnexpectedExternalError } from 'vs/base/common/errors';
 import { Iterable } from 'vs/base/common/iterator';
 import { IDisposable, toDisposable } from 'vs/base/common/lifecycle';
 import { IChatWidgetService } from 'vs/workbench/contrib/chat/browser/chat';
-import { ChatDynamicReferenceModel } from 'vs/workbench/contrib/chat/browser/contrib/chatDynamicReferences';
+import { ChatDynamicVariableModel } from 'vs/workbench/contrib/chat/browser/contrib/chatDynamicVariables';
 import { IChatModel } from 'vs/workbench/contrib/chat/common/chatModel';
-import { IParsedChatRequest, ChatRequestVariablePart, ChatRequestDynamicReferencePart } from 'vs/workbench/contrib/chat/common/chatParserTypes';
-import { IChatVariablesService, IChatRequestVariableValue, IChatVariableData, IChatVariableResolver, IChatVariableResolveResult, IDynamicReference } from 'vs/workbench/contrib/chat/common/chatVariables';
+import { IParsedChatRequest, ChatRequestVariablePart, ChatRequestDynamicVariablePart } from 'vs/workbench/contrib/chat/common/chatParserTypes';
+import { IChatVariablesService, IChatRequestVariableValue, IChatVariableData, IChatVariableResolver, IChatVariableResolveResult, IDynamicVariable } from 'vs/workbench/contrib/chat/common/chatVariables';
 
 interface IChatData {
 	data: IChatVariableData;
@@ -47,10 +47,12 @@ export class ChatVariablesService implements IChatVariablesService {
 							}
 						}).catch(onUnexpectedExternalError));
 					}
-				} else if (part instanceof ChatRequestDynamicReferencePart) {
-					// Maybe the dynamic reference should include a full IChatRequestVariableValue[] at the time it is inserted?
-					resolvedVariables[part.referenceText] = [{ level: 'full', value: part.data.toString() }];
-					parsedPrompt[i] = part.promptText;
+				} else if (part instanceof ChatRequestDynamicVariablePart) {
+					const referenceName = this.getUniqueReferenceName(part.referenceText, resolvedVariables);
+					resolvedVariables[referenceName] = part.data;
+					const safeText = part.text.replace(/[\[\]]/g, '_');
+					const safeTarget = referenceName.replace(/[\(\)]/g, '_');
+					parsedPrompt[i] = `[${safeText}](values:${safeTarget})`;
 				} else {
 					parsedPrompt[i] = part.promptText;
 				}
@@ -64,6 +66,14 @@ export class ChatVariablesService implements IChatVariablesService {
 		};
 	}
 
+	private getUniqueReferenceName(name: string, vars: Record<string, any>): string {
+		let i = 1;
+		while (vars[name]) {
+			name = `${name}_${i++}`;
+		}
+		return name;
+	}
+
 	hasVariable(name: string): boolean {
 		return this._resolver.has(name.toLowerCase());
 	}
@@ -73,7 +83,7 @@ export class ChatVariablesService implements IChatVariablesService {
 		return Iterable.filter(all, data => !data.hidden);
 	}
 
-	getDynamicReferences(sessionId: string): ReadonlyArray<IDynamicReference> {
+	getDynamicVariables(sessionId: string): ReadonlyArray<IDynamicVariable> {
 		// This is slightly wrong... the parser pulls dynamic references from the input widget, but there is no guarantee that message came from the input here.
 		// Need to ...
 		// - Parser takes list of dynamic references (annoying)
@@ -83,12 +93,12 @@ export class ChatVariablesService implements IChatVariablesService {
 			return [];
 		}
 
-		const model = widget.getContrib<ChatDynamicReferenceModel>(ChatDynamicReferenceModel.ID);
+		const model = widget.getContrib<ChatDynamicVariableModel>(ChatDynamicVariableModel.ID);
 		if (!model) {
 			return [];
 		}
 
-		return model.references;
+		return model.variables;
 	}
 
 	registerVariable(data: IChatVariableData, resolver: IChatVariableResolver): IDisposable {
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatViewPane.ts b/src/vs/workbench/contrib/csChat/browser/csChatViewPane.ts
index 8ea8b39634d..f8f7aca63de 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatViewPane.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatViewPane.ts
@@ -22,7 +22,7 @@ import { Memento } from 'vs/workbench/common/memento';
 import { SIDE_BAR_FOREGROUND } from 'vs/workbench/common/theme';
 import { IViewDescriptorService } from 'vs/workbench/common/views';
 import { IChatViewPane } from 'vs/workbench/contrib/chat/browser/chat';
-import { IViewState, ChatWidget } from 'vs/workbench/contrib/chat/browser/chatWidget';
+import { IChatViewState, ChatWidget } from 'vs/workbench/contrib/chat/browser/chatWidget';
 import { IChatModel } from 'vs/workbench/contrib/chat/common/chatModel';
 import { IChatService } from 'vs/workbench/contrib/chat/common/chatService';
 
@@ -30,7 +30,7 @@ export interface IChatViewOptions {
 	readonly providerId: string;
 }
 
-interface IViewPaneState extends IViewState {
+interface IViewPaneState extends IChatViewState {
 	sessionId?: string;
 }
 
@@ -43,7 +43,7 @@ export class ChatViewPane extends ViewPane implements IChatViewPane {
 
 	private modelDisposables = this._register(new DisposableStore());
 	private memento: Memento;
-	private viewState: IViewPaneState;
+	private readonly viewState: IViewPaneState;
 	private didProviderRegistrationFail = false;
 
 	constructor(
@@ -199,6 +199,7 @@ export class ChatViewPane extends ViewPane implements IChatViewPane {
 
 			const widgetViewState = this._widget.getViewState();
 			this.viewState.inputValue = widgetViewState.inputValue;
+			this.viewState.inputState = widgetViewState.inputState;
 			this.memento.saveMemento();
 		}
 
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatWidget.ts b/src/vs/workbench/contrib/csChat/browser/csChatWidget.ts
index 0bf13a5db1a..443afc6be81 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatWidget.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatWidget.ts
@@ -39,9 +39,10 @@ function revealLastElement(list: WorkbenchObjectTree<any>) {
 	list.scrollTop = list.scrollHeight - list.renderHeight;
 }
 
-export interface IViewState {
+export type IChatInputState = Record<string, any>;
+export interface IChatViewState {
 	inputValue?: string;
-	// renderData
+	inputState?: IChatInputState;
 }
 
 export interface IChatWidgetStyles {
@@ -53,6 +54,16 @@ export interface IChatWidgetStyles {
 
 export interface IChatWidgetContrib extends IDisposable {
 	readonly id: string;
+
+	/**
+	 * A piece of state which is related to the input editor of the chat widget
+	 */
+	getInputState?(): any;
+
+	/**
+	 * Called with the result of getInputState when navigating input history.
+	 */
+	setInputState?(s: any): void;
 }
 
 export class ChatWidget extends Disposable implements IChatWidget {
@@ -390,6 +401,13 @@ export class ChatWidget extends Disposable implements IChatWidget {
 		}));
 		this.inputPart.render(container, '', this);
 
+		this._register(this.inputPart.onDidLoadInputState(state => {
+			this.contribs.forEach(c => {
+				if (c.setInputState && typeof state === 'object' && state?.[c.id]) {
+					c.setInputState(state[c.id]);
+				}
+			});
+		}));
 		this._register(this.inputPart.onDidFocus(() => this._onDidFocus.fire()));
 		this._register(this.inputPart.onDidAcceptFollowup(e => {
 			if (!this.viewModel) {
@@ -423,7 +441,7 @@ export class ChatWidget extends Disposable implements IChatWidget {
 		this.container.style.setProperty('--vscode-interactive-session-foreground', this.editorOptions.configuration.foreground?.toString() ?? '');
 	}
 
-	setModel(model: IChatModel, viewState: IViewState): void {
+	setModel(model: IChatModel, viewState: IChatViewState): void {
 		if (!this.container) {
 			throw new Error('Call render() before setModel()');
 		}
@@ -439,11 +457,19 @@ export class ChatWidget extends Disposable implements IChatWidget {
 			}
 		}));
 		this.viewModelDisposables.add(this.viewModel.onDidDisposeModel(() => {
+			// Ensure that view state is saved here, because we will load it again when a new model is assigned
+			this.inputPart.saveState();
+
 			// Disposes the viewmodel and listeners
 			this.viewModel = undefined;
 			this.onDidChangeItems();
 		}));
 		this.inputPart.setState(model.providerId, viewState.inputValue);
+		this.contribs.forEach(c => {
+			if (c.setInputState && viewState.inputState?.[c.id]) {
+				c.setInputState(viewState.inputState?.[c.id]);
+			}
+		});
 
 		if (this.tree) {
 			this.onDidChangeItems();
@@ -478,7 +504,7 @@ export class ChatWidget extends Disposable implements IChatWidget {
 		this.viewModel?.resetInputPlaceholder();
 	}
 
-	updateInput(value = ''): void {
+	setInput(value = ''): void {
 		this.inputPart.setValue(value);
 	}
 
@@ -494,6 +520,16 @@ export class ChatWidget extends Disposable implements IChatWidget {
 		this._acceptInput({ prefix });
 	}
 
+	private collectInputState(): IChatInputState {
+		const inputState: IChatInputState = {};
+		this.contribs.forEach(c => {
+			if (c.getInputState) {
+				inputState[c.id] = c.getInputState();
+			}
+		});
+		return inputState;
+	}
+
 	private async _acceptInput(opts: { query: string } | { prefix: string } | undefined): Promise<void> {
 		if (this.viewModel) {
 			this._onDidAcceptInput.fire();
@@ -507,7 +543,8 @@ export class ChatWidget extends Disposable implements IChatWidget {
 			const result = await this.chatService.sendRequest(this.viewModel.sessionId, input);
 
 			if (result) {
-				this.inputPart.acceptInput(isUserQuery ? input : undefined);
+				const inputState = this.collectInputState();
+				this.inputPart.acceptInput(isUserQuery ? input : undefined, isUserQuery ? inputState : undefined);
 				result.responseCompletePromise.then(async () => {
 					const responses = this.viewModel?.getItems().filter(isResponseVM);
 					const lastResponse = responses?.[responses.length - 1];
@@ -673,9 +710,9 @@ export class ChatWidget extends Disposable implements IChatWidget {
 		this.inputPart.saveState();
 	}
 
-	getViewState(): IViewState {
+	getViewState(): IChatViewState {
 		this.inputPart.saveState();
-		return { inputValue: this.getInput() };
+		return { inputValue: this.getInput(), inputState: this.collectInputState() };
 	}
 }
 
diff --git a/src/vs/workbench/contrib/csChat/browser/media/csChat.css b/src/vs/workbench/contrib/csChat/browser/media/csChat.css
index bf7a1b0afdc..de89b0c9c7c 100644
--- a/src/vs/workbench/contrib/csChat/browser/media/csChat.css
+++ b/src/vs/workbench/contrib/csChat/browser/media/csChat.css
@@ -57,7 +57,7 @@
 	width: 11px;
 }
 
-.interactive-item-container:not(.show-progress) .chat-animated-ellipsis {
+.interactive-item-container:not(.show-detail-progress) .chat-animated-ellipsis {
 	display: none;
 }
 
@@ -520,6 +520,11 @@
 .interactive-item-container .value .interactive-response-placeholder-content {
 	color: var(--vscode-editorGhostText-foreground);
 	font-size: 12px;
+	margin-bottom: 16px;
+}
+
+.interactive-item-container .value .interactive-response-placeholder-content p {
+	margin: 0;
 }
 
 .interactive-response  .interactive-response-codicon-details {
@@ -602,6 +607,7 @@
 	flex-direction: column;
 	gap: 4px;
 	margin-left: 4px;
+	white-space: normal;
 }
 
 .interactive-item-container .progress-steps .progress-step {
@@ -611,7 +617,12 @@
 	opacity: 0.7;
 }
 
-.interactive-item-container .progress-steps .progress-step .codicon-check {
+.interactive-item-container .progress-steps .progress-step .codicon {
+	/* Very aggressive list styles try to apply focus colors to every codicon in a list row. */
+	color: var(--vscode-icon-foreground) !important;
+}
+
+.interactive-item-container .progress-steps .progress-step .codicon.codicon-check {
 	font-size: 14px;
-	color: var(--vscode-debugIcon-startForeground);
+	color: var(--vscode-debugIcon-startForeground) !important;
 }
diff --git a/src/vs/workbench/contrib/csChat/browser/media/csChatEditor.css b/src/vs/workbench/contrib/csChat/browser/media/csChatEditor.css
deleted file mode 100644
index fb57658b021..00000000000
--- a/src/vs/workbench/contrib/csChat/browser/media/csChatEditor.css
+++ /dev/null
@@ -1,11 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-
-.vs .show-file-icons .chat-editor-label.file-icon::before,
-.show-file-icons .chat-editor-label.file-icon::before {
-	content: '\EAC7';
-	font-family: 'codicon';
-	font-size: 16px;
-}
diff --git a/src/vs/workbench/contrib/csChat/common/csChatContextKeys.ts b/src/vs/workbench/contrib/csChat/common/csChatContextKeys.ts
index 85941ee0fd4..d5cb83c170a 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatContextKeys.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatContextKeys.ts
@@ -19,3 +19,4 @@ export const CONTEXT_IN_CHAT_INPUT = new RawContextKey<boolean>('inChatInput', f
 export const CONTEXT_IN_CHAT_SESSION = new RawContextKey<boolean>('inChat', false, { type: 'boolean', description: localize('inChat', "True when focus is in the chat widget, false otherwise.") });
 
 export const CONTEXT_PROVIDER_EXISTS = new RawContextKey<boolean>('hasChatProvider', false, { type: 'boolean', description: localize('hasChatProvider', "True when some chat provider has been registered.") });
+export const CONTEXT_CHAT_INPUT_CURSOR_AT_TOP = new RawContextKey<boolean>('chatCursorAtTop', false);
diff --git a/src/vs/workbench/contrib/csChat/common/csChatModel.ts b/src/vs/workbench/contrib/csChat/common/csChatModel.ts
index 2b8e3e3292a..1e5fcfc1b0f 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatModel.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatModel.ts
@@ -654,7 +654,7 @@ export class ChatModel extends Disposable implements IChatModel {
 
 		if (progress.kind === 'vulnerability') {
 			// TODO@roblourens ChatModel should just work with strings
-			request.response.updateContent({ kind: 'markdownVuln', content: { value: progress.content }, title: progress.title, description: progress.description }, quiet);
+			request.response.updateContent({ kind: 'markdownVuln', content: { value: progress.content }, vulnerabilities: progress.vulnerabilities }, quiet);
 		} else if (progress.kind === 'content' || progress.kind === 'markdownContent' || progress.kind === 'asyncContent' || progress.kind === 'treeData' || progress.kind === 'inlineReference' || progress.kind === 'markdownVuln') {
 			request.response.updateContent(progress, quiet);
 		} else if (progress.kind === 'usedContext' || progress.kind === 'reference' || progress.kind === 'progressMessage') {
diff --git a/src/vs/workbench/contrib/csChat/common/csChatParserTypes.ts b/src/vs/workbench/contrib/csChat/common/csChatParserTypes.ts
index c0954e40b23..7363f5cffcb 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatParserTypes.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatParserTypes.ts
@@ -3,11 +3,12 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 
-import { URI } from 'vs/base/common/uri';
+import { revive } from 'vs/base/common/marshalling';
 import { IOffsetRange, OffsetRange } from 'vs/editor/common/core/offsetRange';
 import { IRange } from 'vs/editor/common/core/range';
 import { IChatAgent, IChatAgentCommand } from 'vs/workbench/contrib/chat/common/chatAgents';
-import { ISlashCommand } from 'vs/workbench/contrib/chat/common/chatService';
+import { IChatSlashData } from 'vs/workbench/contrib/chat/common/chatSlashCommands';
+import { IChatRequestVariableValue } from 'vs/workbench/contrib/chat/common/chatVariables';
 
 // These are in a separate file to avoid circular dependencies with the dependencies of the parser
 
@@ -97,7 +98,7 @@ export class ChatRequestAgentSubcommandPart implements IParsedChatRequestPart {
 export class ChatRequestSlashCommandPart implements IParsedChatRequestPart {
 	static readonly Kind = 'slash';
 	readonly kind = ChatRequestSlashCommandPart.Kind;
-	constructor(readonly range: OffsetRange, readonly editorRange: IRange, readonly slashCommand: ISlashCommand) { }
+	constructor(readonly range: OffsetRange, readonly editorRange: IRange, readonly slashCommand: IChatSlashData) { }
 
 	get text(): string {
 		return `${chatSubcommandLeader}${this.slashCommand.command}`;
@@ -111,21 +112,18 @@ export class ChatRequestSlashCommandPart implements IParsedChatRequestPart {
 /**
  * An invocation of a dynamic reference like '#file:'
  */
-export class ChatRequestDynamicReferencePart implements IParsedChatRequestPart {
+export class ChatRequestDynamicVariablePart implements IParsedChatRequestPart {
 	static readonly Kind = 'dynamic';
-	readonly kind = ChatRequestDynamicReferencePart.Kind;
-	constructor(readonly range: OffsetRange, readonly editorRange: IRange, readonly name: string, readonly arg: string, readonly data: URI) { }
+	readonly kind = ChatRequestDynamicVariablePart.Kind;
+	constructor(readonly range: OffsetRange, readonly editorRange: IRange, readonly text: string, readonly data: IChatRequestVariableValue[]) { }
 
 	get referenceText(): string {
-		return `${this.name}:${this.arg}`;
-	}
-
-	get text(): string {
-		return `${chatVariableLeader}${this.referenceText}`;
+		return this.text;
 	}
 
 	get promptText(): string {
-		return `[${this.text}](values:${this.referenceText})`;
+		// This needs to be dynamically generated for de-duping
+		return ``;
 	}
 }
 
@@ -164,13 +162,12 @@ export function reviveParsedChatRequest(serialized: IParsedChatRequest): IParsed
 					part.editorRange,
 					(part as ChatRequestSlashCommandPart).slashCommand
 				);
-			} else if (part.kind === ChatRequestDynamicReferencePart.Kind) {
-				return new ChatRequestDynamicReferencePart(
+			} else if (part.kind === ChatRequestDynamicVariablePart.Kind) {
+				return new ChatRequestDynamicVariablePart(
 					new OffsetRange(part.range.start, part.range.endExclusive),
 					part.editorRange,
-					(part as ChatRequestDynamicReferencePart).name,
-					(part as ChatRequestDynamicReferencePart).arg,
-					URI.revive((part as ChatRequestDynamicReferencePart).data)
+					(part as ChatRequestDynamicVariablePart).text,
+					revive((part as ChatRequestDynamicVariablePart).data)
 				);
 			} else {
 				throw new Error(`Unknown chat request part: ${part.kind}`);
diff --git a/src/vs/workbench/contrib/csChat/common/csChatProvider.ts b/src/vs/workbench/contrib/csChat/common/csChatProvider.ts
index 8bd56ef0465..468e31b58b1 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatProvider.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatProvider.ts
@@ -29,7 +29,7 @@ export interface IChatResponseFragment {
 
 export interface IChatResponseProviderMetadata {
 	readonly extension: ExtensionIdentifier;
-	readonly displayName: string;
+	readonly model: string;
 	readonly description?: string;
 }
 
@@ -44,6 +44,8 @@ export interface IChatProviderService {
 
 	readonly _serviceBrand: undefined;
 
+	lookupChatResponseProvider(identifier: string): IChatResponseProviderMetadata | undefined;
+
 	registerChatResponseProvider(identifier: string, provider: IChatResponseProvider): IDisposable;
 
 	fetchChatResponse(identifier: string, messages: IChatMessage[], options: { [name: string]: any }, progress: IProgress<IChatResponseFragment>, token: CancellationToken): Promise<any>;
@@ -54,6 +56,9 @@ export class ChatProviderService implements IChatProviderService {
 
 	private readonly _providers: Map<string, IChatResponseProvider> = new Map();
 
+	lookupChatResponseProvider(identifier: string): IChatResponseProviderMetadata | undefined {
+		return this._providers.get(identifier)?.metadata;
+	}
 
 	registerChatResponseProvider(identifier: string, provider: IChatResponseProvider): IDisposable {
 		if (this._providers.has(identifier)) {
diff --git a/src/vs/workbench/contrib/csChat/common/csChatRequestParser.ts b/src/vs/workbench/contrib/csChat/common/csChatRequestParser.ts
index 4a47172525c..cdc91180453 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatRequestParser.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatRequestParser.ts
@@ -8,14 +8,13 @@ import { OffsetRange } from 'vs/editor/common/core/offsetRange';
 import { IPosition, Position } from 'vs/editor/common/core/position';
 import { Range } from 'vs/editor/common/core/range';
 import { IChatAgentService } from 'vs/workbench/contrib/chat/common/chatAgents';
-import { ChatRequestAgentPart, ChatRequestAgentSubcommandPart, ChatRequestDynamicReferencePart, ChatRequestSlashCommandPart, ChatRequestTextPart, ChatRequestVariablePart, IParsedChatRequest, IParsedChatRequestPart, chatAgentLeader, chatSubcommandLeader, chatVariableLeader } from 'vs/workbench/contrib/chat/common/chatParserTypes';
+import { ChatRequestAgentPart, ChatRequestAgentSubcommandPart, ChatRequestDynamicVariablePart, ChatRequestSlashCommandPart, ChatRequestTextPart, ChatRequestVariablePart, IParsedChatRequest, IParsedChatRequestPart, chatAgentLeader, chatSubcommandLeader, chatVariableLeader } from 'vs/workbench/contrib/chat/common/chatParserTypes';
 import { IChatSlashCommandService } from 'vs/workbench/contrib/chat/common/chatSlashCommands';
-import { IChatVariablesService, IDynamicReference } from 'vs/workbench/contrib/chat/common/chatVariables';
+import { IChatVariablesService, IDynamicVariable } from 'vs/workbench/contrib/chat/common/chatVariables';
 
 const agentReg = /^@([\w_\-]+)(?=(\s|$|\b))/i; // An @-agent
 const variableReg = /^#([\w_\-]+)(:\d+)?(?=(\s|$|\b))/i; // A #-variable with an optional numeric : arg (@response:2)
 const slashReg = /\/([\w_\-]+)(?=(\s|$|\b))/i; // A / command
-const variableWithArgReg = /\#([\w_\-]+):([\w_\-\.]+)(?=(\s|$|\b))/i; // A variable with a string : arg (#file:foo.ts)
 
 export class ChatRequestParser {
 	constructor(
@@ -26,7 +25,7 @@ export class ChatRequestParser {
 
 	async parseChatRequest(sessionId: string, message: string): Promise<IParsedChatRequest> {
 		const parts: IParsedChatRequestPart[] = [];
-		const references = this.variableService.getDynamicReferences(sessionId); // must access this list before any async calls
+		const references = this.variableService.getDynamicVariables(sessionId); // must access this list before any async calls
 
 		let lineNumber = 1;
 		let column = 1;
@@ -36,14 +35,17 @@ export class ChatRequestParser {
 			let newPart: IParsedChatRequestPart | undefined;
 			if (previousChar.match(/\s/) || i === 0) {
 				if (char === chatVariableLeader) {
-					newPart = this.tryToParseVariable(message.slice(i), i, new Position(lineNumber, column), parts) ||
-						await this.tryToParseDynamicVariable(message.slice(i), i, new Position(lineNumber, column), references);
+					newPart = this.tryToParseVariable(message.slice(i), i, new Position(lineNumber, column), parts);
 				} else if (char === chatAgentLeader) {
 					newPart = this.tryToParseAgent(message.slice(i), message, i, new Position(lineNumber, column), parts);
 				} else if (char === chatSubcommandLeader) {
 					// TODO try to make this sync
 					newPart = await this.tryToParseSlashCommand(sessionId, message.slice(i), message, i, new Position(lineNumber, column), parts);
 				}
+
+				if (!newPart) {
+					newPart = this.tryToParseDynamicVariable(message.slice(i), i, new Position(lineNumber, column), references);
+				}
 			}
 
 			if (newPart) {
@@ -185,26 +187,15 @@ export class ChatRequestParser {
 		return;
 	}
 
-	private async tryToParseDynamicVariable(message: string, offset: number, position: IPosition, references: ReadonlyArray<IDynamicReference>): Promise<ChatRequestDynamicReferencePart | undefined> {
-		const nextVarMatch = message.match(variableWithArgReg);
-		if (!nextVarMatch) {
-			return;
-		}
-
-		const [full, name, arg] = nextVarMatch;
-		const range = new OffsetRange(offset, offset + full.length);
-		const editorRange = new Range(position.lineNumber, position.column, position.lineNumber, position.column + full.length);
-
-		if (name !== 'file') {
-			// I suppose we support other types later
-			return;
-		}
-
+	private tryToParseDynamicVariable(message: string, offset: number, position: IPosition, references: ReadonlyArray<IDynamicVariable>): ChatRequestDynamicVariablePart | undefined {
 		const refAtThisPosition = references.find(r =>
 			r.range.startLineNumber === position.lineNumber &&
 			r.range.startColumn === position.column);
 		if (refAtThisPosition) {
-			return new ChatRequestDynamicReferencePart(range, editorRange, name, arg, refAtThisPosition.data);
+			const length = refAtThisPosition.range.endColumn - refAtThisPosition.range.startColumn;
+			const text = message.substring(0, length);
+			const range = new OffsetRange(offset, offset + length);
+			return new ChatRequestDynamicVariablePart(range, refAtThisPosition.range, text, refAtThisPosition.data);
 		}
 
 		return;
diff --git a/src/vs/workbench/contrib/csChat/common/csChatService.ts b/src/vs/workbench/contrib/csChat/common/csChatService.ts
index a5376b97e0e..8b2d49825af 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatService.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatService.ts
@@ -10,6 +10,7 @@ import { IDisposable } from 'vs/base/common/lifecycle';
 import { URI } from 'vs/base/common/uri';
 import { IRange, Range } from 'vs/editor/common/core/range';
 import { Location, ProviderResult } from 'vs/editor/common/languages';
+import { FileType } from 'vs/platform/files/common/files';
 import { createDecorator } from 'vs/platform/instantiation/common/instantiation';
 import { IChatAgentCommand, IChatAgentData } from 'vs/workbench/contrib/chat/common/chatAgents';
 import { ChatModel, IChatModel, ISerializableChatData } from 'vs/workbench/contrib/chat/common/chatModel';
@@ -51,6 +52,7 @@ export interface IChatResponse {
 export interface IChatResponseProgressFileTreeData {
 	label: string;
 	uri: URI;
+	type?: FileType;
 	children?: IChatResponseProgressFileTreeData[];
 }
 
@@ -131,25 +133,28 @@ export interface IChatProgressMessage {
 	kind: 'progressMessage';
 }
 
-export interface IChatAgentContentWithVulnerability {
-	content: string;
+export interface IChatAgentVulnerabilityDetails {
 	title: string;
 	description: string;
+}
+
+export interface IChatAgentContentWithVulnerabilities {
+	content: string;
+	vulnerabilities?: IChatAgentVulnerabilityDetails[];
 	kind: 'vulnerability';
 }
 
 // TODO@roblourens Temp until I get MarkdownString out of ChatModel
 export interface IChatAgentMarkdownContentWithVulnerability {
 	content: IMarkdownString;
-	title: string;
-	description: string;
+	vulnerabilities?: IChatAgentVulnerabilityDetails[];
 	kind: 'markdownVuln';
 }
 
 export type IChatProgress =
 	| IChatContent
 	| IChatMarkdownContent
-	| IChatAgentContentWithVulnerability
+	| IChatAgentContentWithVulnerabilities
 	| IChatAgentMarkdownContentWithVulnerability
 	| IChatTreeData
 	| IChatAsyncContent
@@ -168,35 +173,6 @@ export interface IChatProvider {
 	provideSampleQuestions?(token: CancellationToken): ProviderResult<IChatReplyFollowup[] | undefined>;
 }
 
-export interface ISlashCommand {
-	command: string;
-	sortText?: string;
-	detail?: string;
-
-	/**
-	 * Whether the command should execute as soon
-	 * as it is entered. Defaults to `false`.
-	 */
-	executeImmediately?: boolean;
-	/**
-	 * Whether executing the command puts the
-	 * chat into a persistent mode, where the
-	 * slash command is prepended to the chat input.
-	 */
-	shouldRepopulate?: boolean;
-	/**
-	 * Placeholder text to render in the chat input
-	 * when the slash command has been repopulated.
-	 * Has no effect if `shouldRepopulate` is `false`.
-	 */
-	followupPlaceholder?: string;
-	/**
-	 * The slash command(s) that this command wants to be
-	 * deprioritized in favor of.
-	 */
-	yieldsTo?: ReadonlyArray<{ readonly command: string }>;
-}
-
 export interface IChatReplyFollowup {
 	kind: 'reply';
 	message: string;
@@ -226,7 +202,7 @@ export interface IChatVoteAction {
 	reportIssue?: boolean;
 }
 
-export enum InteractiveSessionCopyKind {
+export enum ChatAgentCopyKind {
 	// Keyboard shortcut or context menu
 	Action = 1,
 	Toolbar = 2
@@ -235,7 +211,7 @@ export enum InteractiveSessionCopyKind {
 export interface IChatCopyAction {
 	kind: 'copy';
 	codeBlockIndex: number;
-	copyType: InteractiveSessionCopyKind;
+	copyKind: ChatAgentCopyKind;
 	copiedCharacters: number;
 	totalCharacters: number;
 	copiedText: string;
diff --git a/src/vs/workbench/contrib/csChat/common/csChatServiceImpl.ts b/src/vs/workbench/contrib/csChat/common/csChatServiceImpl.ts
index a6775318b6c..6c873f5a4f5 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatServiceImpl.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatServiceImpl.ts
@@ -3,8 +3,7 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 
-import { CancelablePromise, createCancelablePromise } from 'vs/base/common/async';
-import { CancellationToken } from 'vs/base/common/cancellation';
+import { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';
 import { Emitter, Event } from 'vs/base/common/event';
 import { MarkdownString } from 'vs/base/common/htmlContent';
 import { Iterable } from 'vs/base/common/iterator';
@@ -24,10 +23,10 @@ import { IWorkspaceContextService } from 'vs/platform/workspace/common/workspace
 import { IChatAgentCommand, IChatAgentData, IChatAgentRequest, IChatAgentService } from 'vs/workbench/contrib/chat/common/chatAgents';
 import { CONTEXT_PROVIDER_EXISTS } from 'vs/workbench/contrib/chat/common/chatContextKeys';
 import { ChatModel, ChatModelInitState, ChatRequestModel, ChatWelcomeMessageModel, IChatModel, ISerializableChatData, ISerializableChatsData } from 'vs/workbench/contrib/chat/common/chatModel';
-import { ChatRequestAgentPart, ChatRequestAgentSubcommandPart, ChatRequestSlashCommandPart } from 'vs/workbench/contrib/chat/common/chatParserTypes';
+import { ChatRequestAgentPart, ChatRequestAgentSubcommandPart, ChatRequestSlashCommandPart, IParsedChatRequest } from 'vs/workbench/contrib/chat/common/chatParserTypes';
 import { ChatMessageRole, IChatMessage } from 'vs/workbench/contrib/chat/common/chatProvider';
 import { ChatRequestParser } from 'vs/workbench/contrib/chat/common/chatRequestParser';
-import { IChat, IChatCompleteResponse, IChatDetail, IChatDynamicRequest, IChatFollowup, IChatProgress, IChatProvider, IChatProviderInfo, IChatResponse, IChatService, IChatTransferredSessionData, IChatUserActionEvent, InteractiveSessionCopyKind, InteractiveSessionVoteDirection } from 'vs/workbench/contrib/chat/common/chatService';
+import { IChat, IChatCompleteResponse, IChatDetail, IChatDynamicRequest, IChatFollowup, IChatProgress, IChatProvider, IChatProviderInfo, IChatResponse, IChatService, IChatTransferredSessionData, IChatUserActionEvent, ChatAgentCopyKind, InteractiveSessionVoteDirection } from 'vs/workbench/contrib/chat/common/chatService';
 import { IChatSlashCommandService } from 'vs/workbench/contrib/chat/common/chatSlashCommands';
 import { IChatVariablesService } from 'vs/workbench/contrib/chat/common/chatVariables';
 import { IExtensionService } from 'vs/workbench/services/extensions/common/extensions';
@@ -135,7 +134,7 @@ export class ChatService extends Disposable implements IChatService {
 	private readonly _providers = new Map<string, IChatProvider>();
 
 	private readonly _sessionModels = this._register(new DisposableMap<string, ChatModel>());
-	private readonly _pendingRequests = new Map<string, CancelablePromise<void>>();
+	private readonly _pendingRequests = this._register(new DisposableMap<string, CancellationTokenSource>());
 	private readonly _persistedSessions: ISerializableChatsData;
 	private readonly _hasProvider: IContextKey<boolean>;
 
@@ -225,7 +224,7 @@ export class ChatService extends Disposable implements IChatService {
 		} else if (action.action.kind === 'copy') {
 			this.telemetryService.publicLog2<ChatCopyEvent, ChatCopyClassification>('interactiveSessionCopy', {
 				providerId: action.providerId,
-				copyKind: action.action.copyType === InteractiveSessionCopyKind.Action ? 'action' : 'toolbar'
+				copyKind: action.action.copyKind === ChatAgentCopyKind.Action ? 'action' : 'toolbar'
 			});
 		} else if (action.action.kind === 'insert') {
 			this.telemetryService.publicLog2<ChatInsertEvent, ChatInsertClassification>('interactiveSessionInsert', {
@@ -461,7 +460,9 @@ export class ChatService extends Disposable implements IChatService {
 		let gotProgress = false;
 		const requestType = commandPart ? 'slashCommand' : 'string';
 
-		const rawResponsePromise = createCancelablePromise<void>(async token => {
+		const source = new CancellationTokenSource();
+		const token = source.token;
+		const sendRequestInternal = async () => {
 			const progressCallback = (progress: IChatProgress) => {
 				if (token.isCancellationRequested) {
 					return;
@@ -599,10 +600,11 @@ export class ChatService extends Disposable implements IChatService {
 			} finally {
 				listener.dispose();
 			}
-		});
-		this._pendingRequests.set(model.sessionId, rawResponsePromise);
+		};
+		const rawResponsePromise = sendRequestInternal();
+		this._pendingRequests.set(model.sessionId, source);
 		rawResponsePromise.finally(() => {
-			this._pendingRequests.delete(model.sessionId);
+			this._pendingRequests.deleteAndDispose(model.sessionId);
 		});
 		return rawResponsePromise;
 	}
@@ -631,7 +633,7 @@ export class ChatService extends Disposable implements IChatService {
 		return Array.from(this._providers.keys());
 	}
 
-	async addCompleteRequest(sessionId: string, message: string, response: IChatCompleteResponse): Promise<void> {
+	async addCompleteRequest(sessionId: string, message: IParsedChatRequest | string, response: IChatCompleteResponse): Promise<void> {
 		this.trace('addCompleteRequest', `message: ${message}`);
 
 		const model = this._sessionModels.get(sessionId);
@@ -640,7 +642,9 @@ export class ChatService extends Disposable implements IChatService {
 		}
 
 		await model.waitForInitialization();
-		const parsedRequest = await this.instantiationService.createInstance(ChatRequestParser).parseChatRequest(sessionId, message);
+		const parsedRequest = typeof message === 'string' ?
+			await this.instantiationService.createInstance(ChatRequestParser).parseChatRequest(sessionId, message) :
+			message;
 		const request = model.addRequest(parsedRequest);
 		if (typeof response.message === 'string') {
 			model.acceptResponseProgress(request, { content: response.message, kind: 'content' });
@@ -662,6 +666,7 @@ export class ChatService extends Disposable implements IChatService {
 	cancelCurrentRequestForSession(sessionId: string): void {
 		this.trace('cancelCurrentRequestForSession', `sessionId: ${sessionId}`);
 		this._pendingRequests.get(sessionId)?.cancel();
+		this._pendingRequests.deleteAndDispose(sessionId);
 	}
 
 	clearSession(sessionId: string): void {
@@ -675,6 +680,7 @@ export class ChatService extends Disposable implements IChatService {
 
 		this._sessionModels.deleteAndDispose(sessionId);
 		this._pendingRequests.get(sessionId)?.cancel();
+		this._pendingRequests.deleteAndDispose(sessionId);
 		this._onDidDisposeSession.fire({ sessionId, providerId: model.providerId, reason: 'cleared' });
 	}
 
diff --git a/src/vs/workbench/contrib/csChat/common/csChatVariables.ts b/src/vs/workbench/contrib/csChat/common/csChatVariables.ts
index 0a75c905b4f..9aea4d07820 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatVariables.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatVariables.ts
@@ -20,7 +20,8 @@ export interface IChatVariableData {
 
 export interface IChatRequestVariableValue {
 	level: 'short' | 'medium' | 'full';
-	value: string;
+	kind?: string;
+	value: string | URI | any;
 	description?: string;
 }
 
@@ -36,7 +37,7 @@ export interface IChatVariablesService {
 	registerVariable(data: IChatVariableData, resolver: IChatVariableResolver): IDisposable;
 	hasVariable(name: string): boolean;
 	getVariables(): Iterable<Readonly<IChatVariableData>>;
-	getDynamicReferences(sessionId: string): ReadonlyArray<IDynamicReference>; // should be its own service?
+	getDynamicVariables(sessionId: string): ReadonlyArray<IDynamicVariable>; // should be its own service?
 
 	/**
 	 * Resolves all variables that occur in `prompt`
@@ -49,8 +50,7 @@ export interface IChatVariableResolveResult {
 	prompt: string;
 }
 
-export interface IDynamicReference {
+export interface IDynamicVariable {
 	range: IRange;
-	// data: any; // File details for a file, something else for a different type of thing, is it typed?
-	data: URI;
+	data: IChatRequestVariableValue[];
 }
diff --git a/src/vs/workbench/contrib/csChat/common/csChatWidgetHistoryService.ts b/src/vs/workbench/contrib/csChat/common/csChatWidgetHistoryService.ts
index 6d96d44a4fb..03948260a67 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatWidgetHistoryService.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatWidgetHistoryService.ts
@@ -8,6 +8,11 @@ import { createDecorator } from 'vs/platform/instantiation/common/instantiation'
 import { IStorageService, StorageScope, StorageTarget } from 'vs/platform/storage/common/storage';
 import { Memento } from 'vs/workbench/common/memento';
 
+export interface IChatHistoryEntry {
+	text: string;
+	state?: any;
+}
+
 export const IChatWidgetHistoryService = createDecorator<IChatWidgetHistoryService>('IChatWidgetHistoryService');
 export interface IChatWidgetHistoryService {
 	_serviceBrand: undefined;
@@ -15,12 +20,12 @@ export interface IChatWidgetHistoryService {
 	readonly onDidClearHistory: Event<void>;
 
 	clearHistory(): void;
-	getHistory(providerId: string): string[];
-	saveHistory(providerId: string, history: string[]): void;
+	getHistory(providerId: string): IChatHistoryEntry[];
+	saveHistory(providerId: string, history: IChatHistoryEntry[]): void;
 }
 
 interface IChatHistory {
-	history: { [providerId: string]: string[] };
+	history: { [providerId: string]: IChatHistoryEntry[] };
 }
 
 export class ChatWidgetHistoryService implements IChatWidgetHistoryService {
@@ -36,14 +41,20 @@ export class ChatWidgetHistoryService implements IChatWidgetHistoryService {
 		@IStorageService storageService: IStorageService
 	) {
 		this.memento = new Memento('interactive-session', storageService);
-		this.viewState = this.memento.getMemento(StorageScope.WORKSPACE, StorageTarget.MACHINE) as IChatHistory;
+		const loadedState = this.memento.getMemento(StorageScope.WORKSPACE, StorageTarget.MACHINE) as IChatHistory;
+		for (const provider in loadedState.history) {
+			// Migration from old format
+			loadedState.history[provider] = loadedState.history[provider].map(entry => typeof entry === 'string' ? { text: entry } : entry);
+		}
+
+		this.viewState = loadedState;
 	}
 
-	getHistory(providerId: string): string[] {
+	getHistory(providerId: string): IChatHistoryEntry[] {
 		return this.viewState.history?.[providerId] ?? [];
 	}
 
-	saveHistory(providerId: string, history: string[]): void {
+	saveHistory(providerId: string, history: IChatHistoryEntry[]): void {
 		if (!this.viewState.history) {
 			this.viewState.history = {};
 		}
diff --git a/src/vs/workbench/contrib/csChat/electron-sandbox/actions/csVoiceChatActions.ts b/src/vs/workbench/contrib/csChat/electron-sandbox/actions/csVoiceChatActions.ts
index e82a6afea81..cce939e31a6 100644
--- a/src/vs/workbench/contrib/csChat/electron-sandbox/actions/csVoiceChatActions.ts
+++ b/src/vs/workbench/contrib/csChat/electron-sandbox/actions/csVoiceChatActions.ts
@@ -18,7 +18,7 @@ import { spinningLoading } from 'vs/platform/theme/common/iconRegistry';
 import { CHAT_CATEGORY } from 'vs/workbench/contrib/chat/browser/actions/chatActions';
 import { IChatWidget, IChatWidgetService, IQuickChatService } from 'vs/workbench/contrib/chat/browser/chat';
 import { IChatService } from 'vs/workbench/contrib/chat/common/chatService';
-import { CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST, MENU_INLINE_CHAT_WIDGET } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
+import { CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST, MENU_INLINE_CHAT_INPUT } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
 import { CONTEXT_CHAT_REQUEST_IN_PROGRESS, CONTEXT_PROVIDER_EXISTS } from 'vs/workbench/contrib/chat/common/chatContextKeys';
 import { InlineChatController } from 'vs/workbench/contrib/inlineChat/browser/inlineChatController';
 import { IEditorService } from 'vs/workbench/services/editor/common/editorService';
@@ -169,7 +169,7 @@ class VoiceChatSessionControllerFactory {
 			onDidCancelInput: Event.filter(viewsService.onDidChangeViewVisibility, e => e.id === chatContributionService.getViewIdForProvider(chatView.providerId)),
 			focusInput: () => chatView.focusInput(),
 			acceptInput: () => chatView.acceptInput(),
-			updateInput: text => chatView.updateInput(text),
+			updateInput: text => chatView.setInput(text),
 			getInput: () => chatView.getInput(),
 			setInputPlaceholder: text => chatView.setInputPlaceholder(text),
 			clearInputPlaceholder: () => chatView.resetInputPlaceholder()
@@ -183,7 +183,7 @@ class VoiceChatSessionControllerFactory {
 			onDidCancelInput: quickChatService.onDidClose,
 			focusInput: () => quickChat.focusInput(),
 			acceptInput: () => quickChat.acceptInput(),
-			updateInput: text => quickChat.updateInput(text),
+			updateInput: text => quickChat.setInput(text),
 			getInput: () => quickChat.getInput(),
 			setInputPlaceholder: text => quickChat.setInputPlaceholder(text),
 			clearInputPlaceholder: () => quickChat.resetInputPlaceholder()
@@ -474,7 +474,7 @@ export class StartVoiceChatAction extends Action2 {
 				group: 'navigation',
 				order: -1
 			}, {
-				id: MENU_INLINE_CHAT_WIDGET,
+				id: MENU_INLINE_CHAT_INPUT,
 				when: ContextKeyExpr.and(HasSpeechProvider, CONTEXT_INLINE_VOICE_CHAT_IN_PROGRESS.negate()),
 				group: 'main',
 				order: -1
@@ -654,7 +654,7 @@ export class StopListeningInInlineChatAction extends Action2 {
 			precondition: ContextKeyExpr.and(HasSpeechProvider, CONTEXT_INLINE_VOICE_CHAT_IN_PROGRESS),
 			icon: spinningLoading,
 			menu: [{
-				id: MENU_INLINE_CHAT_WIDGET,
+				id: MENU_INLINE_CHAT_INPUT,
 				when: ContextKeyExpr.and(HasSpeechProvider, CONTEXT_INLINE_VOICE_CHAT_IN_PROGRESS),
 				group: 'main',
 				order: -1
diff --git a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChat.contribution.ts b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChat.contribution.ts
index 502d37bbc81..b896a99bf9b 100644
--- a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChat.contribution.ts
+++ b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChat.contribution.ts
@@ -7,7 +7,7 @@ import { registerAction2 } from 'vs/platform/actions/common/actions';
 import { EditorContributionInstantiation, registerEditorContribution } from 'vs/editor/browser/editorExtensions';
 import { InlineChatController } from 'vs/workbench/contrib/inlineChat/browser/inlineChatController';
 import * as InlineChatActions from 'vs/workbench/contrib/inlineChat/browser/inlineChatActions';
-import { IInlineChatService, INLINE_CHAT_DECORATIONS_ID, INLINE_CHAT_ID, INTERACTIVE_EDITOR_ACCESSIBILITY_HELP_ID } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
+import { IInlineChatService, INLINE_CHAT_ID, INTERACTIVE_EDITOR_ACCESSIBILITY_HELP_ID } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
 import { InstantiationType, registerSingleton } from 'vs/platform/instantiation/common/extensions';
 import { InlineChatServiceImpl } from 'vs/workbench/contrib/inlineChat/common/inlineChatServiceImpl';
 import { IInlineChatSessionService, InlineChatSessionService } from 'vs/workbench/contrib/inlineChat/browser/inlineChatSession';
@@ -16,16 +16,16 @@ import { LifecyclePhase } from 'vs/workbench/services/lifecycle/common/lifecycle
 import { InlineChatNotebookContribution } from 'vs/workbench/contrib/inlineChat/browser/inlineChatNotebook';
 import { IWorkbenchContributionsRegistry, Extensions as WorkbenchExtensions } from 'vs/workbench/common/contributions';
 import { InlineChatAccessibleViewContribution } from './inlineChatAccessibleView';
-import { InlineChatDecorationsContribution } from 'vs/workbench/contrib/inlineChat/browser/inlineChatDecorations';
 
 registerSingleton(IInlineChatService, InlineChatServiceImpl, InstantiationType.Delayed);
 registerSingleton(IInlineChatSessionService, InlineChatSessionService, InstantiationType.Delayed);
 
 registerEditorContribution(INLINE_CHAT_ID, InlineChatController, EditorContributionInstantiation.Eager); // EAGER because of notebook dispose/create of editors
 registerEditorContribution(INTERACTIVE_EDITOR_ACCESSIBILITY_HELP_ID, InlineChatActions.InlineAccessibilityHelpContribution, EditorContributionInstantiation.Eventually);
-registerEditorContribution(INLINE_CHAT_DECORATIONS_ID, InlineChatDecorationsContribution, EditorContributionInstantiation.AfterFirstRender);
 
 registerAction2(InlineChatActions.StartSessionAction);
+registerAction2(InlineChatActions.CloseAction);
+registerAction2(InlineChatActions.ConfigureInlineChatAction);
 registerAction2(InlineChatActions.UnstashSessionAction);
 registerAction2(InlineChatActions.MakeRequestAction);
 registerAction2(InlineChatActions.StopRequestAction);
@@ -44,11 +44,11 @@ registerAction2(InlineChatActions.ViewInChatAction);
 registerAction2(InlineChatActions.ExpandMessageAction);
 registerAction2(InlineChatActions.ContractMessageAction);
 
-registerAction2(InlineChatActions.ToggleInlineDiff);
+registerAction2(InlineChatActions.ToggleDiffForChange);
 registerAction2(InlineChatActions.FeebackHelpfulCommand);
 registerAction2(InlineChatActions.FeebackUnhelpfulCommand);
 registerAction2(InlineChatActions.ReportIssueForBugCommand);
-registerAction2(InlineChatActions.ApplyPreviewEdits);
+registerAction2(InlineChatActions.AcceptChanges);
 
 registerAction2(InlineChatActions.CopyRecordings);
 
diff --git a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChat.css b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChat.css
index d48e61ff247..7aaf6275dc7 100644
--- a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChat.css
+++ b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChat.css
@@ -84,6 +84,10 @@
 	gap: 4px;
 }
 
+.monaco-editor .inline-chat .body > .widget-toolbar {
+	padding-left: 4px;
+}
+
 /* progress bit */
 
 .monaco-editor .inline-chat .progress {
@@ -93,7 +97,7 @@
 }
 
 /* UGLY - fighting against workbench styles */
-.monaco-workbench .part.editor>.content .monaco-editor .inline-chat .progress .monaco-progress-container {
+.monaco-workbench .part.editor > .content .monaco-editor .inline-chat .progress .monaco-progress-container {
 	top: 0;
 }
 
@@ -119,7 +123,7 @@
 	color: var(--vscode-descriptionForeground);
 	font-size: 11px;
 	align-self: baseline;
-	display: flex;
+	display: inline-flex;
 }
 
 .monaco-editor .inline-chat .status .label.hidden {
@@ -141,7 +145,6 @@
 	padding-left: 10px;
 	padding-right: 4px;
 	margin-left: auto;
-	align-self: center;
 }
 
 .monaco-editor .inline-chat .status .label .slash-command-pill CODE {
@@ -151,15 +154,8 @@
 	color: var(--vscode-chat-slashCommandForeground);
 }
 
-.monaco-editor .inline-chat .markdownMessage {
-	padding: 10px 5px;
-}
-
-.monaco-editor .inline-chat .markdownMessage.hidden {
-	display: none;
-}
 
-.monaco-editor .inline-chat .markdownMessage .message * {
+/* .monaco-editor .inline-chat .markdownMessage .message * {
 	margin: unset;
 }
 
@@ -170,13 +166,10 @@
 	background-color: var(--vscode-textPreformat-background);
 	padding: 1px 3px;
 	border-radius: 4px;
-}
+} */
 
-.monaco-editor .inline-chat .markdownMessage .message .interactive-result-code-block {
-	margin: 16px 0;
-}
 
-.monaco-editor .inline-chat .markdownMessage .message {
+.monaco-editor .inline-chat .chatMessage .chatMessageContent .value {
 	-webkit-line-clamp: initial;
 	-webkit-box-orient: vertical;
 	overflow: hidden;
@@ -185,11 +178,11 @@
 	user-select: text;
 }
 
-.monaco-editor .inline-chat .markdownMessage .message[state="cropped"] {
+.monaco-editor .inline-chat .chatMessage .chatMessageContent[state="cropped"] .value {
 	-webkit-line-clamp: var(--vscode-inline-chat-cropped, 3);
 }
 
-.monaco-editor .inline-chat .markdownMessage .message[state="expanded"] {
+.monaco-editor .inline-chat .chatMessage .chatMessageContent[state="expanded"] .value {
 	-webkit-line-clamp: var(--vscode-inline-chat-expanded, 10);
 }
 
@@ -310,13 +303,35 @@
 	display: none;
 }
 
+.monaco-editor .inline-chat-toolbar {
+	display: flex;
+}
+
+.monaco-editor .inline-chat-toolbar > .monaco-button{
+	margin-right: 6px;
+}
+
+.monaco-editor .inline-chat-toolbar .action-label.checked {
+	color: var(--vscode-inputOption-activeForeground);
+	background-color: var(--vscode-inputOption-activeBackground);
+	outline: 1px solid var(--vscode-inputOption-activeBorder);
+}
+
 /* decoration styles */
 
-.monaco-editor .inline-chat-lines-deleted-range-inline {
-	text-decoration: line-through;
-	background-color: var(--vscode-diffEditor-removedTextBackground);
-	opacity: 0.6;
+.monaco-editor .inline-chat-inserted-range {
+	background-color: var(--vscode-inlineChatDiff-inserted);
+}
+
+.monaco-editor .inline-chat-inserted-range-linehighlight {
+	background-color: var(--vscode-diffEditor-insertedLineBackground);
 }
+
+.monaco-editor .inline-chat-original-zone2 {
+	background-color: var(--vscode-diffEditor-removedLineBackground);
+	opacity: 0.8;
+}
+
 .monaco-editor .inline-chat-lines-inserted-range {
 	background-color: var(--vscode-diffEditor-insertedTextBackground);
 }
diff --git a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatActions.ts b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatActions.ts
index 19ea38a6238..57851523450 100644
--- a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatActions.ts
+++ b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatActions.ts
@@ -4,15 +4,15 @@
  *--------------------------------------------------------------------------------------------*/
 
 import { Codicon } from 'vs/base/common/codicons';
-import { KeyCode, KeyMod } from 'vs/base/common/keyCodes';
+import { KeyChord, KeyCode, KeyMod } from 'vs/base/common/keyCodes';
 import { ICodeEditor } from 'vs/editor/browser/editorBrowser';
 import { EditorAction2 } from 'vs/editor/browser/editorExtensions';
 import { EmbeddedCodeEditorWidget, EmbeddedDiffEditorWidget } from 'vs/editor/browser/widget/embeddedCodeEditorWidget';
 import { EditorContextKeys } from 'vs/editor/common/editorContextKeys';
 import { InlineChatController, InlineChatRunOptions } from 'vs/workbench/contrib/inlineChat/browser/inlineChatController';
-import { CTX_INLINE_CHAT_FOCUSED, CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST, CTX_INLINE_CHAT_HAS_PROVIDER, CTX_INLINE_CHAT_INNER_CURSOR_FIRST, CTX_INLINE_CHAT_INNER_CURSOR_LAST, CTX_INLINE_CHAT_EMPTY, CTX_INLINE_CHAT_OUTER_CURSOR_POSITION, CTX_INLINE_CHAT_VISIBLE, MENU_INLINE_CHAT_WIDGET, MENU_INLINE_CHAT_WIDGET_DISCARD, MENU_INLINE_CHAT_WIDGET_STATUS, CTX_INLINE_CHAT_LAST_FEEDBACK, CTX_INLINE_CHAT_EDIT_MODE, EditMode, CTX_INLINE_CHAT_LAST_RESPONSE_TYPE, MENU_INLINE_CHAT_WIDGET_MARKDOWN_MESSAGE, CTX_INLINE_CHAT_MESSAGE_CROP_STATE, CTX_INLINE_CHAT_DOCUMENT_CHANGED, CTX_INLINE_CHAT_DID_EDIT, CTX_INLINE_CHAT_HAS_STASHED_SESSION, MENU_INLINE_CHAT_WIDGET_FEEDBACK, ACTION_ACCEPT_CHANGES, ACTION_REGENERATE_RESPONSE, InlineChatResponseType, CTX_INLINE_CHAT_RESPONSE_TYPES, InlineChateResponseTypes, ACTION_VIEW_IN_CHAT, CTX_INLINE_CHAT_USER_DID_EDIT, MENU_INLINE_CHAT_WIDGET_TOGGLE, CTX_INLINE_CHAT_INNER_CURSOR_START, CTX_INLINE_CHAT_INNER_CURSOR_END, CTX_INLINE_CHAT_RESPONSE_FOCUSED, CTX_INLINE_CHAT_SUPPORT_ISSUE_REPORTING, InlineChatResponseFeedbackKind, CTX_INLINE_CHAT_TOOLBAR_ICON_ENABLED } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
-import { localize } from 'vs/nls';
-import { IAction2Options, MenuId, MenuRegistry } from 'vs/platform/actions/common/actions';
+import { CTX_INLINE_CHAT_FOCUSED, CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST, CTX_INLINE_CHAT_HAS_PROVIDER, CTX_INLINE_CHAT_INNER_CURSOR_FIRST, CTX_INLINE_CHAT_INNER_CURSOR_LAST, CTX_INLINE_CHAT_EMPTY, CTX_INLINE_CHAT_OUTER_CURSOR_POSITION, CTX_INLINE_CHAT_VISIBLE, MENU_INLINE_CHAT_INPUT, MENU_INLINE_CHAT_WIDGET_DISCARD, MENU_INLINE_CHAT_WIDGET_STATUS, CTX_INLINE_CHAT_LAST_FEEDBACK, CTX_INLINE_CHAT_EDIT_MODE, EditMode, MENU_INLINE_CHAT_WIDGET_MARKDOWN_MESSAGE, CTX_INLINE_CHAT_MESSAGE_CROP_STATE, CTX_INLINE_CHAT_DOCUMENT_CHANGED, CTX_INLINE_CHAT_DID_EDIT, CTX_INLINE_CHAT_HAS_STASHED_SESSION, MENU_INLINE_CHAT_WIDGET_FEEDBACK, ACTION_ACCEPT_CHANGES, ACTION_REGENERATE_RESPONSE, CTX_INLINE_CHAT_RESPONSE_TYPES, InlineChatResponseTypes, ACTION_VIEW_IN_CHAT, CTX_INLINE_CHAT_USER_DID_EDIT, CTX_INLINE_CHAT_INNER_CURSOR_START, CTX_INLINE_CHAT_INNER_CURSOR_END, CTX_INLINE_CHAT_RESPONSE_FOCUSED, CTX_INLINE_CHAT_SUPPORT_ISSUE_REPORTING, InlineChatResponseFeedbackKind, CTX_INLINE_CHAT_CHANGE_SHOWS_DIFF, CTX_INLINE_CHAT_CHANGE_HAS_DIFF, MENU_INLINE_CHAT_WIDGET } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
+import { localize, localize2 } from 'vs/nls';
+import { IAction2Options, MenuRegistry } from 'vs/platform/actions/common/actions';
 import { IClipboardService } from 'vs/platform/clipboard/common/clipboardService';
 import { ContextKeyExpr } from 'vs/platform/contextkey/common/contextkey';
 import { ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';
@@ -27,9 +27,9 @@ import { runAccessibilityHelpAction } from 'vs/workbench/contrib/chat/browser/ac
 import { CONTEXT_ACCESSIBILITY_MODE_ENABLED } from 'vs/platform/accessibility/common/accessibility';
 import { Disposable } from 'vs/base/common/lifecycle';
 import { CommandsRegistry } from 'vs/platform/commands/common/commands';
-import { IConfigurationService } from 'vs/platform/configuration/common/configuration';
 import { AccessibilityHelpAction } from 'vs/workbench/contrib/accessibility/browser/accessibleViewActions';
 import { registerIcon } from 'vs/platform/theme/common/iconRegistry';
+import { IPreferencesService } from 'vs/workbench/services/preferences/common/preferences';
 
 CommandsRegistry.registerCommandAlias('interactiveEditor.start', 'inlineChat.start');
 export const LOCALIZED_START_INLINE_CHAT_STRING = localize('run', 'Start Inline Chat');
@@ -43,14 +43,14 @@ export class StartSessionAction extends EditorAction2 {
 			title: { value: LOCALIZED_START_INLINE_CHAT_STRING, original: 'Start Inline Chat' },
 			category: AbstractInlineChatAction.category,
 			f1: true,
-			precondition: ContextKeyExpr.and(CTX_INLINE_CHAT_HAS_PROVIDER, CTX_INLINE_CHAT_VISIBLE.toNegated(), EditorContextKeys.focus),
-			icon: START_INLINE_CHAT,
-			menu: [{
-				id: MenuId.EditorTitle,
-				when: ContextKeyExpr.and(CTX_INLINE_CHAT_TOOLBAR_ICON_ENABLED, CTX_INLINE_CHAT_HAS_PROVIDER, CTX_INLINE_CHAT_VISIBLE.toNegated(), EditorContextKeys.focus),
-				group: 'navigation',
-				order: -1000000, // at the very front
-			}],
+			precondition: ContextKeyExpr.and(CTX_INLINE_CHAT_HAS_PROVIDER, EditorContextKeys.writable),
+			keybinding: {
+				when: EditorContextKeys.focus,
+				weight: KeybindingWeight.WorkbenchContrib,
+				primary: KeyMod.CtrlCmd | KeyCode.KeyI,
+				secondary: [KeyChord(KeyMod.CtrlCmd | KeyCode.KeyK, KeyCode.KeyI)],
+			},
+			icon: START_INLINE_CHAT
 		});
 	}
 
@@ -62,7 +62,7 @@ export class StartSessionAction extends EditorAction2 {
 		if (arg && InlineChatRunOptions.isInteractiveEditorOptions(arg)) {
 			options = arg;
 		}
-		InlineChatController.get(editor)?.run(options);
+		InlineChatController.get(editor)?.run({ ...options });
 	}
 }
 
@@ -142,7 +142,7 @@ export class MakeRequestAction extends AbstractInlineChatAction {
 				primary: KeyCode.Enter
 			},
 			menu: {
-				id: MENU_INLINE_CHAT_WIDGET,
+				id: MENU_INLINE_CHAT_INPUT,
 				group: 'main',
 				order: 1,
 				when: CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST.isEqualTo(false)
@@ -163,7 +163,7 @@ export class ReRunRequestAction extends AbstractInlineChatAction {
 			title: localize('rerun', 'Regenerate Response'),
 			shortTitle: localize('rerunShort', 'Regenerate'),
 			icon: Codicon.refresh,
-			precondition: ContextKeyExpr.and(CTX_INLINE_CHAT_VISIBLE, CTX_INLINE_CHAT_EMPTY.negate(), CTX_INLINE_CHAT_LAST_RESPONSE_TYPE),
+			precondition: ContextKeyExpr.and(CTX_INLINE_CHAT_VISIBLE, CTX_INLINE_CHAT_EMPTY.negate(), CTX_INLINE_CHAT_RESPONSE_TYPES.notEqualsTo(InlineChatResponseTypes.Empty)),
 			menu: {
 				id: MENU_INLINE_CHAT_WIDGET_STATUS,
 				group: '2_feedback',
@@ -187,7 +187,7 @@ export class StopRequestAction extends AbstractInlineChatAction {
 			icon: Codicon.debugStop,
 			precondition: ContextKeyExpr.and(CTX_INLINE_CHAT_VISIBLE, CTX_INLINE_CHAT_EMPTY.negate(), CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST),
 			menu: {
-				id: MENU_INLINE_CHAT_WIDGET,
+				id: MENU_INLINE_CHAT_INPUT,
 				group: 'main',
 				order: 1,
 				when: CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST
@@ -212,7 +212,7 @@ export class ArrowOutUpAction extends AbstractInlineChatAction {
 			precondition: ContextKeyExpr.and(CTX_INLINE_CHAT_FOCUSED, CTX_INLINE_CHAT_INNER_CURSOR_FIRST, EditorContextKeys.isEmbeddedDiffEditor.negate(), CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()),
 			keybinding: {
 				weight: KeybindingWeight.EditorCore,
-				primary: KeyCode.UpArrow
+				primary: KeyMod.CtrlCmd | KeyCode.UpArrow
 			}
 		});
 	}
@@ -230,7 +230,7 @@ export class ArrowOutDownAction extends AbstractInlineChatAction {
 			precondition: ContextKeyExpr.and(CTX_INLINE_CHAT_FOCUSED, CTX_INLINE_CHAT_INNER_CURSOR_LAST, EditorContextKeys.isEmbeddedDiffEditor.negate(), CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()),
 			keybinding: {
 				weight: KeybindingWeight.EditorCore,
-				primary: KeyCode.DownArrow
+				primary: KeyMod.CtrlCmd | KeyCode.DownArrow
 			}
 		});
 	}
@@ -252,11 +252,11 @@ export class FocusInlineChat extends EditorAction2 {
 			keybinding: [{
 				weight: KeybindingWeight.EditorCore + 10, // win against core_command
 				when: ContextKeyExpr.and(CTX_INLINE_CHAT_OUTER_CURSOR_POSITION.isEqualTo('above'), EditorContextKeys.isEmbeddedDiffEditor.negate()),
-				primary: KeyCode.DownArrow,
+				primary: KeyMod.CtrlCmd | KeyCode.DownArrow,
 			}, {
 				weight: KeybindingWeight.EditorCore + 10, // win against core_command
 				when: ContextKeyExpr.and(CTX_INLINE_CHAT_OUTER_CURSOR_POSITION.isEqualTo('below'), EditorContextKeys.isEmbeddedDiffEditor.negate()),
-				primary: KeyCode.UpArrow,
+				primary: KeyMod.CtrlCmd | KeyCode.UpArrow,
 			}]
 		});
 	}
@@ -275,7 +275,7 @@ export class PreviousFromHistory extends AbstractInlineChatAction {
 			precondition: ContextKeyExpr.and(CTX_INLINE_CHAT_FOCUSED, CTX_INLINE_CHAT_INNER_CURSOR_START),
 			keybinding: {
 				weight: KeybindingWeight.EditorCore + 10, // win against core_command
-				primary: KeyMod.CtrlCmd | KeyCode.UpArrow,
+				primary: KeyCode.UpArrow,
 			}
 		});
 	}
@@ -294,7 +294,7 @@ export class NextFromHistory extends AbstractInlineChatAction {
 			precondition: ContextKeyExpr.and(CTX_INLINE_CHAT_FOCUSED, CTX_INLINE_CHAT_INNER_CURSOR_END),
 			keybinding: {
 				weight: KeybindingWeight.EditorCore + 10, // win against core_command
-				primary: KeyMod.CtrlCmd | KeyCode.DownArrow,
+				primary: KeyCode.DownArrow,
 			}
 		});
 	}
@@ -310,7 +310,7 @@ MenuRegistry.appendMenuItem(MENU_INLINE_CHAT_WIDGET_STATUS, {
 	icon: Codicon.discard,
 	group: '0_main',
 	order: 2,
-	when: ContextKeyExpr.and(CTX_INLINE_CHAT_EDIT_MODE.notEqualsTo(EditMode.Preview), CTX_INLINE_CHAT_RESPONSE_TYPES.notEqualsTo(InlineChateResponseTypes.OnlyMessages)),
+	when: ContextKeyExpr.and(CTX_INLINE_CHAT_EDIT_MODE.notEqualsTo(EditMode.Preview), CTX_INLINE_CHAT_EDIT_MODE.notEqualsTo(EditMode.Live), CTX_INLINE_CHAT_RESPONSE_TYPES.notEqualsTo(InlineChatResponseTypes.OnlyMessages)),
 	rememberDefaultAction: true
 });
 
@@ -395,6 +395,33 @@ export class DiscardUndoToNewFileAction extends AbstractInlineChatAction {
 	}
 }
 
+export class ToggleDiffForChange extends AbstractInlineChatAction {
+
+	constructor() {
+		super({
+			id: 'inlineChat.toggleDiff',
+			precondition: ContextKeyExpr.and(CTX_INLINE_CHAT_VISIBLE, CTX_INLINE_CHAT_EDIT_MODE.isEqualTo(EditMode.Live), CTX_INLINE_CHAT_CHANGE_HAS_DIFF),
+			title: localize2('showChanges', 'Show Changes'),
+			icon: Codicon.diffSingle,
+			toggled: {
+				condition: CTX_INLINE_CHAT_CHANGE_SHOWS_DIFF,
+			},
+			menu: [
+				{
+					id: MENU_INLINE_CHAT_WIDGET_FEEDBACK,
+					group: '1_main',
+					when: ContextKeyExpr.and(CTX_INLINE_CHAT_EDIT_MODE.isEqualTo(EditMode.Live), CTX_INLINE_CHAT_CHANGE_HAS_DIFF)
+				}
+			]
+		});
+	}
+
+	override runInlineChatCommand(accessor: ServicesAccessor, ctrl: InlineChatController): void {
+		ctrl.toggleDiff();
+	}
+}
+
+
 export class FeebackHelpfulCommand extends AbstractInlineChatAction {
 	constructor() {
 		super({
@@ -405,7 +432,7 @@ export class FeebackHelpfulCommand extends AbstractInlineChatAction {
 			toggled: CTX_INLINE_CHAT_LAST_FEEDBACK.isEqualTo('helpful'),
 			menu: {
 				id: MENU_INLINE_CHAT_WIDGET_FEEDBACK,
-				when: CTX_INLINE_CHAT_LAST_RESPONSE_TYPE.notEqualsTo(undefined),
+				when: CTX_INLINE_CHAT_RESPONSE_TYPES.notEqualsTo(InlineChatResponseTypes.Empty),
 				group: '2_feedback',
 				order: 1
 			}
@@ -427,7 +454,7 @@ export class FeebackUnhelpfulCommand extends AbstractInlineChatAction {
 			toggled: CTX_INLINE_CHAT_LAST_FEEDBACK.isEqualTo('unhelpful'),
 			menu: {
 				id: MENU_INLINE_CHAT_WIDGET_FEEDBACK,
-				when: CTX_INLINE_CHAT_LAST_RESPONSE_TYPE.notEqualsTo(undefined),
+				when: CTX_INLINE_CHAT_RESPONSE_TYPES.notEqualsTo(InlineChatResponseTypes.Empty),
 				group: '2_feedback',
 				order: 2
 			}
@@ -445,13 +472,17 @@ export class ReportIssueForBugCommand extends AbstractInlineChatAction {
 			id: 'inlineChat.reportIssueForBug',
 			title: localize('feedback.reportIssueForBug', 'Report Issue'),
 			icon: Codicon.report,
-			precondition: CTX_INLINE_CHAT_VISIBLE,
-			menu: {
+			precondition: ContextKeyExpr.and(CTX_INLINE_CHAT_VISIBLE, CTX_INLINE_CHAT_RESPONSE_TYPES.notEqualsTo(InlineChatResponseTypes.Empty)),
+			menu: [{
 				id: MENU_INLINE_CHAT_WIDGET_FEEDBACK,
-				when: ContextKeyExpr.and(CTX_INLINE_CHAT_SUPPORT_ISSUE_REPORTING, CTX_INLINE_CHAT_LAST_RESPONSE_TYPE.notEqualsTo(undefined)),
+				when: ContextKeyExpr.and(CTX_INLINE_CHAT_SUPPORT_ISSUE_REPORTING, CTX_INLINE_CHAT_RESPONSE_TYPES.notEqualsTo(InlineChatResponseTypes.Empty)),
 				group: '2_feedback',
 				order: 3
-			}
+			}, {
+				id: MENU_INLINE_CHAT_WIDGET,
+				group: 'config',
+				order: 3
+			}]
 		});
 	}
 
@@ -460,37 +491,8 @@ export class ReportIssueForBugCommand extends AbstractInlineChatAction {
 	}
 }
 
-export class ToggleInlineDiff extends AbstractInlineChatAction {
-
-	constructor() {
-		super({
-			id: 'inlineChat.toggleDiff',
-			title: {
-				original: 'Show Diff',
-				value: localize('showDiff', 'Show Diff'),
-				mnemonicTitle: localize({ key: 'miShowDiff', comment: ['&& denotes a mnemonic'] }, "&&Show Diff"),
-			},
-			toggled: {
-				condition: ContextKeyExpr.equals('config.inlineChat.showDiff', true),
-				title: localize('showDiff2', "Show Diff"),
-				mnemonicTitle: localize({ key: 'miShowDiff2', comment: ['&& denotes a mnemonic'] }, "&&Show Diff")
-			},
-			precondition: ContextKeyExpr.notEquals('config.inlineChat.mode', 'preview'),
-			menu: [
-				{ id: MenuId.CommandPalette },
-				{ id: MENU_INLINE_CHAT_WIDGET_TOGGLE }
-			]
-		});
-	}
-
-	override runInlineChatCommand(accessor: ServicesAccessor, _ctrl: InlineChatController): void {
-		const configurationService = accessor.get(IConfigurationService);
-		const newValue = !configurationService.getValue('inlineChat.showDiff');
-		configurationService.updateValue('inlineChat.showDiff', newValue);
-	}
-}
 
-export class ApplyPreviewEdits extends AbstractInlineChatAction {
+export class AcceptChanges extends AbstractInlineChatAction {
 
 	constructor() {
 		super({
@@ -509,7 +511,7 @@ export class ApplyPreviewEdits extends AbstractInlineChatAction {
 				when: CTX_INLINE_CHAT_USER_DID_EDIT
 			}],
 			menu: {
-				when: CTX_INLINE_CHAT_RESPONSE_TYPES.notEqualsTo(InlineChateResponseTypes.OnlyMessages),
+				when: ContextKeyExpr.and(CTX_INLINE_CHAT_RESPONSE_TYPES.notEqualsTo(InlineChatResponseTypes.OnlyMessages), CTX_INLINE_CHAT_EDIT_MODE.notEqualsTo(EditMode.Live)),
 				id: MENU_INLINE_CHAT_WIDGET_STATUS,
 				group: '0_main',
 				order: 0
@@ -536,7 +538,7 @@ export class CancelSessionAction extends AbstractInlineChatAction {
 			},
 			menu: {
 				id: MENU_INLINE_CHAT_WIDGET_STATUS,
-				when: ContextKeyExpr.or(CTX_INLINE_CHAT_EDIT_MODE.isEqualTo(EditMode.Preview), CTX_INLINE_CHAT_RESPONSE_TYPES.isEqualTo(InlineChateResponseTypes.OnlyMessages)),
+				when: CTX_INLINE_CHAT_EDIT_MODE.isEqualTo(EditMode.Preview),
 				group: '0_main',
 				order: 3
 			}
@@ -548,6 +550,51 @@ export class CancelSessionAction extends AbstractInlineChatAction {
 	}
 }
 
+export class CloseAction extends AbstractInlineChatAction {
+
+	constructor() {
+		super({
+			id: 'inlineChat.close',
+			title: localize('close', 'Close'),
+			icon: Codicon.close,
+			precondition: CTX_INLINE_CHAT_VISIBLE,
+			keybinding: {
+				weight: KeybindingWeight.EditorContrib - 1,
+				primary: KeyCode.Escape
+			},
+			menu: {
+				id: MENU_INLINE_CHAT_WIDGET,
+				group: 'main',
+				order: 0,
+			}
+		});
+	}
+
+	async runInlineChatCommand(_accessor: ServicesAccessor, ctrl: InlineChatController, _editor: ICodeEditor, ..._args: any[]): Promise<void> {
+		ctrl.finishExistingSession();
+	}
+}
+
+export class ConfigureInlineChatAction extends AbstractInlineChatAction {
+	constructor() {
+		super({
+			id: 'inlineChat.configure',
+			title: localize('configure', 'Configure '),
+			icon: Codicon.settingsGear,
+			precondition: CTX_INLINE_CHAT_VISIBLE,
+			menu: {
+				id: MENU_INLINE_CHAT_WIDGET,
+				group: 'config',
+				order: 1,
+			}
+		});
+	}
+
+	async runInlineChatCommand(accessor: ServicesAccessor, ctrl: InlineChatController, _editor: ICodeEditor, ..._args: any[]): Promise<void> {
+		accessor.get(IPreferencesService).openSettings({ query: 'inlineChat' });
+	}
+}
+
 export class CopyRecordings extends AbstractInlineChatAction {
 
 	constructor() {
@@ -596,7 +643,7 @@ export class ViewInChatAction extends AbstractInlineChatAction {
 			precondition: CTX_INLINE_CHAT_VISIBLE,
 			menu: {
 				id: MENU_INLINE_CHAT_WIDGET_STATUS,
-				when: CTX_INLINE_CHAT_LAST_RESPONSE_TYPE.isEqualTo(InlineChatResponseType.Message),
+				when: CTX_INLINE_CHAT_RESPONSE_TYPES.isEqualTo(InlineChatResponseTypes.OnlyMessages),
 				group: '0_main',
 				order: 1
 			}
@@ -616,7 +663,7 @@ export class ExpandMessageAction extends AbstractInlineChatAction {
 			precondition: CTX_INLINE_CHAT_VISIBLE,
 			menu: {
 				id: MENU_INLINE_CHAT_WIDGET_MARKDOWN_MESSAGE,
-				when: ContextKeyExpr.and(CTX_INLINE_CHAT_LAST_RESPONSE_TYPE.isEqualTo('message'), CTX_INLINE_CHAT_MESSAGE_CROP_STATE.isEqualTo('cropped')),
+				when: ContextKeyExpr.and(ContextKeyExpr.or(CTX_INLINE_CHAT_RESPONSE_TYPES.isEqualTo(InlineChatResponseTypes.OnlyMessages), CTX_INLINE_CHAT_RESPONSE_TYPES.isEqualTo(InlineChatResponseTypes.Mixed)), CTX_INLINE_CHAT_MESSAGE_CROP_STATE.isEqualTo('cropped')),
 				group: '2_expandOrContract',
 				order: 1
 			}
@@ -636,7 +683,7 @@ export class ContractMessageAction extends AbstractInlineChatAction {
 			precondition: CTX_INLINE_CHAT_VISIBLE,
 			menu: {
 				id: MENU_INLINE_CHAT_WIDGET_MARKDOWN_MESSAGE,
-				when: ContextKeyExpr.and(CTX_INLINE_CHAT_LAST_RESPONSE_TYPE.isEqualTo('message'), CTX_INLINE_CHAT_MESSAGE_CROP_STATE.isEqualTo('expanded')),
+				when: ContextKeyExpr.and(ContextKeyExpr.or(CTX_INLINE_CHAT_RESPONSE_TYPES.isEqualTo(InlineChatResponseTypes.OnlyMessages), CTX_INLINE_CHAT_RESPONSE_TYPES.isEqualTo(InlineChatResponseTypes.Mixed)), CTX_INLINE_CHAT_MESSAGE_CROP_STATE.isEqualTo('expanded')),
 				group: '2_expandOrContract',
 				order: 1
 			}
diff --git a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatController.ts b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatController.ts
index f9d0c371bcd..0916d9b82a9 100644
--- a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatController.ts
+++ b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatController.ts
@@ -3,18 +3,27 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 
+import { renderMarkdownAsPlaintext } from 'vs/base/browser/markdownRenderer';
 import * as aria from 'vs/base/browser/ui/aria/aria';
 import { Barrier, Queue, raceCancellation, raceCancellationError } from 'vs/base/common/async';
 import { CancellationTokenSource } from 'vs/base/common/cancellation';
 import { toErrorMessage } from 'vs/base/common/errorMessage';
+import { onUnexpectedError } from 'vs/base/common/errors';
 import { Emitter, Event } from 'vs/base/common/event';
+import { MarkdownString } from 'vs/base/common/htmlContent';
+import { Lazy } from 'vs/base/common/lazy';
 import { DisposableStore, IDisposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';
+import { MovingAverage } from 'vs/base/common/numbers';
 import { StopWatch } from 'vs/base/common/stopwatch';
 import { assertType } from 'vs/base/common/types';
+import { generateUuid } from 'vs/base/common/uuid';
 import { ICodeEditor } from 'vs/editor/browser/editorBrowser';
+import { IBulkEditService } from 'vs/editor/browser/services/bulkEditService';
 import { IPosition, Position } from 'vs/editor/common/core/position';
 import { IRange, Range } from 'vs/editor/common/core/range';
+import { ISelection, Selection } from 'vs/editor/common/core/selection';
 import { IEditorContribution } from 'vs/editor/common/editorCommon';
+import { TextEdit } from 'vs/editor/common/languages';
 import { IEditorWorkerService } from 'vs/editor/common/services/editorWorker';
 import { InlineCompletionsController } from 'vs/editor/contrib/inlineCompletions/browser/inlineCompletionsController';
 import { localize } from 'vs/nls';
@@ -24,28 +33,16 @@ import { IContextKey, IContextKeyService } from 'vs/platform/contextkey/common/c
 import { IDialogService } from 'vs/platform/dialogs/common/dialogs';
 import { IInstantiationService, ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';
 import { ILogService } from 'vs/platform/log/common/log';
-import { ReplyResponse, EmptyResponse, ErrorResponse, ExpansionState, IInlineChatSessionService, Session, SessionExchange, SessionPrompt } from 'vs/workbench/contrib/inlineChat/browser/inlineChatSession';
-import { EditModeStrategy, LivePreviewStrategy, LiveStrategy, PreviewStrategy, ProgressingEditsOptions } from 'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies';
-import { IInlineChatMessageAppender, InlineChatZoneWidget } from 'vs/workbench/contrib/inlineChat/browser/inlineChatWidget';
-import { CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST, CTX_INLINE_CHAT_LAST_FEEDBACK, IInlineChatRequest, IInlineChatResponse, INLINE_CHAT_ID, EditMode, InlineChatResponseFeedbackKind, CTX_INLINE_CHAT_LAST_RESPONSE_TYPE, InlineChatResponseType, CTX_INLINE_CHAT_DID_EDIT, CTX_INLINE_CHAT_HAS_STASHED_SESSION, InlineChateResponseTypes, CTX_INLINE_CHAT_RESPONSE_TYPES, CTX_INLINE_CHAT_USER_DID_EDIT, IInlineChatProgressItem, CTX_INLINE_CHAT_SUPPORT_ISSUE_REPORTING } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
-import { IChatAccessibilityService, IChatWidgetService } from 'vs/workbench/contrib/chat/browser/chat';
-import { IChatService } from 'vs/workbench/contrib/chat/common/chatService';
-import { IKeybindingService } from 'vs/platform/keybinding/common/keybinding';
-import { Lazy } from 'vs/base/common/lazy';
 import { Progress } from 'vs/platform/progress/common/progress';
-import { generateUuid } from 'vs/base/common/uuid';
-import { TextEdit } from 'vs/editor/common/languages';
-import { ISelection, Selection } from 'vs/editor/common/core/selection';
-import { onUnexpectedError } from 'vs/base/common/errors';
-import { MarkdownString } from 'vs/base/common/htmlContent';
-import { MovingAverage } from 'vs/base/common/numbers';
-import { ModelDecorationOptions } from 'vs/editor/common/model/textModel';
-import { IModelDeltaDecoration } from 'vs/editor/common/model';
+import { IStorageService, StorageScope, StorageTarget } from 'vs/platform/storage/common/storage';
+import { IChatAccessibilityService, IChatWidgetService } from 'vs/workbench/contrib/chat/browser/chat';
 import { IChatAgentService } from 'vs/workbench/contrib/chat/common/chatAgents';
 import { chatAgentLeader, chatSubcommandLeader } from 'vs/workbench/contrib/chat/common/chatParserTypes';
-import { renderMarkdownAsPlaintext } from 'vs/base/browser/markdownRenderer';
-import { IBulkEditService } from 'vs/editor/browser/services/bulkEditService';
-import { IStorageService, StorageScope, StorageTarget } from 'vs/platform/storage/common/storage';
+import { IChatService } from 'vs/workbench/contrib/chat/common/chatService';
+import { EmptyResponse, ErrorResponse, ExpansionState, IInlineChatSessionService, ReplyResponse, Session, SessionExchange, SessionPrompt } from 'vs/workbench/contrib/inlineChat/browser/inlineChatSession';
+import { EditModeStrategy, LivePreviewStrategy, LiveStrategy, PreviewStrategy, ProgressingEditsOptions } from 'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies';
+import { IInlineChatMessageAppender, InlineChatZoneWidget } from 'vs/workbench/contrib/inlineChat/browser/inlineChatWidget';
+import { CTX_INLINE_CHAT_DID_EDIT, CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST, CTX_INLINE_CHAT_HAS_STASHED_SESSION, CTX_INLINE_CHAT_LAST_FEEDBACK, CTX_INLINE_CHAT_RESPONSE_TYPES, CTX_INLINE_CHAT_SUPPORT_ISSUE_REPORTING, CTX_INLINE_CHAT_USER_DID_EDIT, EditMode, IInlineChatProgressItem, IInlineChatRequest, IInlineChatResponse, INLINE_CHAT_ID, InlineChatConfigKeys, InlineChatResponseFeedbackKind, InlineChatResponseTypes } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
 
 export const enum State {
 	CREATE_SESSION = 'CREATE_SESSION',
@@ -99,13 +96,6 @@ export class InlineChatController implements IEditorContribution {
 		return editor.getContribution<InlineChatController>(INLINE_CHAT_ID);
 	}
 
-	private static _decoBlock = ModelDecorationOptions.register({
-		description: 'inline-chat',
-		showIfCollapsed: false,
-		isWholeLine: true,
-		className: 'inline-chat-block-selection',
-	});
-
 	private static _storageKey = 'inline-chat-history';
 	private static _promptHistory: string[] = [];
 	private _historyOffset: number = -1;
@@ -114,8 +104,7 @@ export class InlineChatController implements IEditorContribution {
 	private readonly _store = new DisposableStore();
 	private readonly _zone: Lazy<InlineChatZoneWidget>;
 	private readonly _ctxHasActiveRequest: IContextKey<boolean>;
-	private readonly _ctxLastResponseType: IContextKey<undefined | InlineChatResponseType>;
-	private readonly _ctxResponseTypes: IContextKey<undefined | InlineChateResponseTypes>;
+	private readonly _ctxResponseTypes: IContextKey<undefined | InlineChatResponseTypes>;
 	private readonly _ctxDidEdit: IContextKey<boolean>;
 	private readonly _ctxUserDidEdit: IContextKey<boolean>;
 	private readonly _ctxLastFeedbackKind: IContextKey<'helpful' | 'unhelpful' | ''>;
@@ -145,7 +134,6 @@ export class InlineChatController implements IEditorContribution {
 		@IDialogService private readonly _dialogService: IDialogService,
 		@IContextKeyService contextKeyService: IContextKeyService,
 		@IAccessibilityService private readonly _accessibilityService: IAccessibilityService,
-		@IKeybindingService private readonly _keybindingService: IKeybindingService,
 		@IChatAccessibilityService private readonly _chatAccessibilityService: IChatAccessibilityService,
 		@IChatAgentService private readonly _chatAgentService: IChatAgentService,
 		@IBulkEditService private readonly _bulkEditService: IBulkEditService,
@@ -155,7 +143,6 @@ export class InlineChatController implements IEditorContribution {
 		this._ctxDidEdit = CTX_INLINE_CHAT_DID_EDIT.bindTo(contextKeyService);
 		this._ctxUserDidEdit = CTX_INLINE_CHAT_USER_DID_EDIT.bindTo(contextKeyService);
 		this._ctxResponseTypes = CTX_INLINE_CHAT_RESPONSE_TYPES.bindTo(contextKeyService);
-		this._ctxLastResponseType = CTX_INLINE_CHAT_LAST_RESPONSE_TYPE.bindTo(contextKeyService);
 		this._ctxLastFeedbackKind = CTX_INLINE_CHAT_LAST_FEEDBACK.bindTo(contextKeyService);
 		this._ctxSupportIssueReporting = CTX_INLINE_CHAT_SUPPORT_ISSUE_REPORTING.bindTo(contextKeyService);
 		this._zone = new Lazy(() => this._store.add(_instaService.createInstance(InlineChatZoneWidget, this._editor)));
@@ -215,7 +202,7 @@ export class InlineChatController implements IEditorContribution {
 	}
 
 	private _getMode(): EditMode {
-		const editMode = this._configurationService.inspect<EditMode>('inlineChat.mode');
+		const editMode = this._configurationService.inspect<EditMode>(InlineChatConfigKeys.Mode);
 		let editModeValue = editMode.value;
 		if (this._accessibilityService.isScreenReaderOptimized() && editModeValue === editMode.defaultValue) {
 			// By default, use preview mode for screen reader users
@@ -240,6 +227,7 @@ export class InlineChatController implements IEditorContribution {
 			if (options.initialSelection) {
 				this._editor.setSelection(options.initialSelection);
 			}
+			this._historyOffset = -1;
 			this._onWillStartSession.fire();
 			this._currentRun = this._nextState(State.CREATE_SESSION, options);
 			await this._currentRun;
@@ -282,22 +270,18 @@ export class InlineChatController implements IEditorContribution {
 			widgetPosition = this._editor.getSelection().getStartPosition().delta(-1);
 		}
 
-		let needsMargin = false;
 		if (initialRender) {
 			this._zone.value.setContainerMargins();
 		}
 
-		if (this._activeSession && (this._activeSession.hasChangedText || this._activeSession.lastExchange)) {
+		if (this._activeSession && !position && (this._activeSession.hasChangedText || this._activeSession.lastExchange)) {
 			widgetPosition = this._activeSession.wholeRange.value.getStartPosition().delta(-1);
 		}
 		if (this._activeSession) {
 			this._zone.value.updateBackgroundColor(widgetPosition, this._activeSession.wholeRange.value);
 		}
-		if (this._strategy) {
-			needsMargin = this._strategy.needsMargin();
-		}
 		if (!this._zone.value.position) {
-			this._zone.value.setWidgetMargins(widgetPosition, !needsMargin ? 0 : undefined);
+			this._zone.value.setWidgetMargins(widgetPosition);
 			this._zone.value.show(widgetPosition);
 		} else {
 			this._zone.value.updatePositionAndHeight(widgetPosition);
@@ -327,7 +311,6 @@ export class InlineChatController implements IEditorContribution {
 
 		this._showWidget(true, initPosition);
 
-		this._zone.value.widget.updateInfo(localize('welcome.1', "AI-generated code may be incorrect"));
 		this._updatePlaceholder();
 
 		if (!session) {
@@ -368,14 +351,14 @@ export class InlineChatController implements IEditorContribution {
 
 		switch (session.editMode) {
 			case EditMode.Live:
-				this._strategy = this._instaService.createInstance(LiveStrategy, session, this._editor, this._zone.value.widget);
+				this._strategy = this._instaService.createInstance(LiveStrategy, session, this._editor, this._zone.value);
 				break;
 			case EditMode.Preview:
-				this._strategy = this._instaService.createInstance(PreviewStrategy, session, this._zone.value.widget);
+				this._strategy = this._instaService.createInstance(PreviewStrategy, session, this._zone.value);
 				break;
 			case EditMode.LivePreview:
 			default:
-				this._strategy = this._instaService.createInstance(LivePreviewStrategy, session, this._editor, this._zone.value.widget);
+				this._strategy = this._instaService.createInstance(LivePreviewStrategy, session, this._editor, this._zone.value);
 				break;
 		}
 
@@ -385,6 +368,7 @@ export class InlineChatController implements IEditorContribution {
 
 	private async [State.INIT_UI](options: InlineChatRunOptions): Promise<State.WAIT_FOR_INPUT | State.SHOW_RESPONSE | State.APPLY_RESPONSE> {
 		assertType(this._activeSession);
+		assertType(this._strategy);
 
 		// hide/cancel inline completions when invoking IE
 		InlineCompletionsController.get(this._editor)?.hide();
@@ -393,16 +377,8 @@ export class InlineChatController implements IEditorContribution {
 
 		const wholeRangeDecoration = this._editor.createDecorationsCollection();
 		const updateWholeRangeDecoration = () => {
-
-			const range = this._activeSession!.wholeRange.value;
-			const decorations: IModelDeltaDecoration[] = [];
-			if (!range.isEmpty()) {
-				decorations.push({
-					range,
-					options: InlineChatController._decoBlock
-				});
-			}
-			wholeRangeDecoration.set(decorations);
+			const newDecorations = this._strategy?.getWholeRangeDecoration() ?? [];
+			wholeRangeDecoration.set(newDecorations);
 		};
 		this._sessionStore.add(toDisposable(() => wholeRangeDecoration.clear()));
 		this._sessionStore.add(this._activeSession.wholeRange.onDidChange(updateWholeRangeDecoration));
@@ -440,14 +416,16 @@ export class InlineChatController implements IEditorContribution {
 			}
 
 			const wholeRange = this._activeSession!.wholeRange;
-			let editIsOutsideOfWholeRange = false;
-			for (const { range } of e.changes) {
-				editIsOutsideOfWholeRange = !Range.areIntersectingOrTouching(range, wholeRange.value);
+			let shouldFinishSession = false;
+			if (this._configurationService.getValue<boolean>(InlineChatConfigKeys.FinishOnType)) {
+				for (const { range } of e.changes) {
+					shouldFinishSession = !Range.areIntersectingOrTouching(range, wholeRange.value);
+				}
 			}
 
-			this._activeSession!.recordExternalEditOccurred(editIsOutsideOfWholeRange);
+			this._activeSession!.recordExternalEditOccurred(shouldFinishSession);
 
-			if (editIsOutsideOfWholeRange) {
+			if (shouldFinishSession) {
 				this._log('text changed outside of whole range, FINISH session');
 				this.finishExistingSession();
 			}
@@ -482,16 +460,7 @@ export class InlineChatController implements IEditorContribution {
 	}
 
 	private _getPlaceholderText(): string {
-		let result = this._forcedPlaceholder ?? this._activeSession?.session.placeholder ?? localize('default.placeholder', "Ask a question");
-		if (typeof this._forcedPlaceholder === 'undefined' && InlineChatController._promptHistory.length > 0) {
-			const kb1 = this._keybindingService.lookupKeybinding('inlineChat.previousFromHistory')?.getLabel();
-			const kb2 = this._keybindingService.lookupKeybinding('inlineChat.nextFromHistory')?.getLabel();
-
-			if (kb1 && kb2) {
-				result = localize('default.placeholder.history', "{0} ({1}, {2} for history)", result, kb1, kb2);
-			}
-		}
-		return result;
+		return this._forcedPlaceholder ?? this._activeSession?.session.placeholder ?? '';
 	}
 
 
@@ -514,13 +483,16 @@ export class InlineChatController implements IEditorContribution {
 
 		} else {
 			const barrier = new Barrier();
-			const msgListener = Event.once(this._messages.event)(m => {
+			const store = new DisposableStore();
+			store.add(this._strategy.onDidAccept(() => this.acceptSession()));
+			store.add(this._strategy.onDidDiscard(() => this.cancelSession()));
+			store.add(Event.once(this._messages.event)(m => {
 				this._log('state=_waitForInput) message received', m);
 				message = m;
 				barrier.open();
-			});
+			}));
 			await barrier.wait();
-			msgListener.dispose();
+			store.dispose();
 		}
 
 		this._zone.value.widget.selectAll(false);
@@ -614,7 +586,7 @@ export class InlineChatController implements IEditorContribution {
 			prompt: this._activeSession.lastInput.value,
 			attempt: this._activeSession.lastInput.attempt,
 			selection: this._editor.getSelection(),
-			wholeRange: this._activeSession.wholeRange.value,
+			wholeRange: this._activeSession.wholeRange.trackedInitialRange,
 			live: this._activeSession.editMode !== EditMode.Preview // TODO@jrieken let extension know what document is used for previewing
 		};
 
@@ -697,10 +669,10 @@ export class InlineChatController implements IEditorContribution {
 		let reply: IInlineChatResponse | null | undefined;
 		try {
 			this._zone.value.widget.updateChatMessage(undefined);
-			this._zone.value.widget.updateMarkdownMessage(undefined);
 			this._zone.value.widget.updateFollowUps(undefined);
 			this._zone.value.widget.updateProgress(true);
 			this._zone.value.widget.updateInfo(!this._activeSession.lastExchange ? localize('thinking', "Thinking\u2026") : '');
+			await this._strategy.start();
 			this._ctxHasActiveRequest.set(true);
 			reply = await raceCancellationError(Promise.resolve(task), requestCts.token);
 
@@ -743,6 +715,10 @@ export class InlineChatController implements IEditorContribution {
 			this._chatAccessibilityService.acceptResponse(a11yResponse, requestId);
 		}
 
+		// todo@jrieken we can likely remove 'trackEdit'
+		const diff = await this._editorWorkerService.computeDiff(this._activeSession.textModel0.uri, this._activeSession.textModelN.uri, { computeMoves: false, maxComputationTimeMs: Number.MAX_SAFE_INTEGER, ignoreTrimWhitespace: false }, 'advanced');
+		this._activeSession.wholeRange.fixup(diff?.changes ?? []);
+
 		progressiveEditsCts.dispose(true);
 		requestCts.dispose();
 		msgListener.dispose();
@@ -807,15 +783,13 @@ export class InlineChatController implements IEditorContribution {
 		}
 	}
 
-	private async[State.SHOW_RESPONSE](): Promise<State.WAIT_FOR_INPUT | State.CANCEL> {
+	private async[State.SHOW_RESPONSE](): Promise<State.WAIT_FOR_INPUT> {
 		assertType(this._activeSession);
 		assertType(this._strategy);
 
 		const { response } = this._activeSession.lastExchange!;
 
-		this._ctxLastResponseType.set(response instanceof ReplyResponse ? response.raw.type : undefined);
-
-		let responseTypes: InlineChateResponseTypes | undefined;
+		let responseTypes: InlineChatResponseTypes | undefined;
 		for (const { response } of this._activeSession.exchanges) {
 
 			const thisType = response instanceof ReplyResponse
@@ -825,13 +799,15 @@ export class InlineChatController implements IEditorContribution {
 			if (responseTypes === undefined) {
 				responseTypes = thisType;
 			} else if (responseTypes !== thisType) {
-				responseTypes = InlineChateResponseTypes.Mixed;
+				responseTypes = InlineChatResponseTypes.Mixed;
 				break;
 			}
 		}
 		this._ctxResponseTypes.set(responseTypes);
 		this._ctxDidEdit.set(this._activeSession.hasChangedText);
 
+		let newPosition: Position | undefined;
+
 		if (response instanceof EmptyResponse) {
 			// show status message
 			const status = localize('empty', "No results, please refine your input and try again");
@@ -854,7 +830,7 @@ export class InlineChatController implements IEditorContribution {
 			this._activeSession.lastExpansionState = this._zone.value.widget.expansionState;
 			this._zone.value.widget.updateToolbar(true);
 
-			await this._strategy.renderChanges(response);
+			newPosition = await this._strategy.renderChanges(response);
 
 			if (this._activeSession.provider.provideFollowups) {
 				const followupCts = new CancellationTokenSource();
@@ -877,7 +853,7 @@ export class InlineChatController implements IEditorContribution {
 				});
 			}
 		}
-		this._showWidget(false);
+		this._showWidget(false, newPosition);
 
 		return State.WAIT_FOR_INPUT;
 	}
@@ -886,7 +862,6 @@ export class InlineChatController implements IEditorContribution {
 
 		this._ctxDidEdit.reset();
 		this._ctxUserDidEdit.reset();
-		this._ctxLastResponseType.reset();
 		this._ctxLastFeedbackKind.reset();
 		this._ctxSupportIssueReporting.reset();
 
@@ -1012,11 +987,15 @@ export class InlineChatController implements IEditorContribution {
 	updateExpansionState(expand: boolean) {
 		if (this._activeSession) {
 			const expansionState = expand ? ExpansionState.EXPANDED : ExpansionState.CROPPED;
-			this._zone.value.widget.updateMarkdownMessageExpansionState(expansionState);
+			this._zone.value.widget.updateChatMessageExpansionState(expansionState);
 			this._activeSession.lastExpansionState = expansionState;
 		}
 	}
 
+	toggleDiff() {
+		this._strategy?.toggleDiff?.();
+	}
+
 	feedbackLast(kind: InlineChatResponseFeedbackKind) {
 		if (this._activeSession?.lastExchange && this._activeSession.lastExchange.response instanceof ReplyResponse) {
 			this._activeSession.provider.handleInlineChatResponseFeedback?.(this._activeSession.session, this._activeSession.lastExchange.response.raw, kind);
diff --git a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatDecorations.ts b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatDecorations.ts
deleted file mode 100644
index 36a03fb663f..00000000000
--- a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatDecorations.ts
+++ /dev/null
@@ -1,267 +0,0 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
-
-import { Codicon } from 'vs/base/common/codicons';
-import { ThemeIcon } from 'vs/base/common/themables';
-import { IActiveCodeEditor, ICodeEditor, IEditorMouseEvent } from 'vs/editor/browser/editorBrowser';
-import { IEditorContribution } from 'vs/editor/common/editorCommon';
-import { GlyphMarginLane, IModelDecorationOptions, IModelDecorationsChangeAccessor, TrackedRangeStickiness } from 'vs/editor/common/model';
-import { ModelDecorationOptions } from 'vs/editor/common/model/textModel';
-import { localize } from 'vs/nls';
-import { registerIcon } from 'vs/platform/theme/common/iconRegistry';
-import { InlineChatController } from 'vs/workbench/contrib/inlineChat/browser/inlineChatController';
-import { IConfigurationService, IConfigurationChangeEvent } from 'vs/platform/configuration/common/configuration';
-import { DisposableStore, Disposable } from 'vs/base/common/lifecycle';
-import { GutterActionsRegistry } from 'vs/workbench/contrib/codeEditor/browser/editorLineNumberMenu';
-import { Action } from 'vs/base/common/actions';
-import { CTX_INLINE_CHAT_TOOLBAR_ICON_ENABLED, IInlineChatService, ShowGutterIcon } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
-import { RunOnceScheduler } from 'vs/base/common/async';
-import { Iterable } from 'vs/base/common/iterator';
-import { Range } from 'vs/editor/common/core/range';
-import { IInlineChatSessionService } from 'vs/workbench/contrib/inlineChat/browser/inlineChatSession';
-import { MarkdownString } from 'vs/base/common/htmlContent';
-import { IKeybindingService } from 'vs/platform/keybinding/common/keybinding';
-import { LOCALIZED_START_INLINE_CHAT_STRING } from 'vs/workbench/contrib/inlineChat/browser/inlineChatActions';
-import { IBreakpoint, IDebugService, IDebugSession } from 'vs/workbench/contrib/debug/common/debug';
-import { IPreferencesService } from 'vs/workbench/services/preferences/common/preferences';
-import { URI } from 'vs/base/common/uri';
-import { IContextKey, IContextKeyService } from 'vs/platform/contextkey/common/contextkey';
-
-const GUTTER_INLINE_CHAT_OPAQUE_ICON = registerIcon('inline-chat-opaque', Codicon.sparkle, localize('startInlineChatOpaqueIcon', 'Icon which spawns the inline chat from the gutter. It is half opaque by default and becomes completely opaque on hover.'));
-const GUTTER_INLINE_CHAT_TRANSPARENT_ICON = registerIcon('inline-chat-transparent', Codicon.sparkle, localize('startInlineChatTransparentIcon', 'Icon which spawns the inline chat from the gutter. It is transparent by default and becomes opaque on hover.'));
-
-export class InlineChatDecorationsContribution extends Disposable implements IEditorContribution {
-
-	private _ctxToolbarIconEnabled: IContextKey<boolean>;
-	private _currentBreakpoints: readonly IBreakpoint[] = [];
-	private _gutterDecorationID: string | undefined;
-	private _inlineChatKeybinding: string | undefined;
-	private _hasInlineChatSession: boolean = false;
-	private _hasActiveDebugSession: boolean = false;
-	private _debugSessions: Set<IDebugSession> = new Set();
-	private readonly _localToDispose = new DisposableStore();
-	private readonly _gutterDecorationOpaque: IModelDecorationOptions;
-	private readonly _gutterDecorationTransparent: IModelDecorationOptions;
-
-	public static readonly TOOLBAR_SETTING_ID = 'inlineChat.showToolbarIcon';
-	public static readonly GUTTER_SETTING_ID = 'inlineChat.showGutterIcon';
-	private static readonly GUTTER_ICON_OPAQUE_CLASSNAME = 'codicon-inline-chat-opaque';
-	private static readonly GUTTER_ICON_TRANSPARENT_CLASSNAME = 'codicon-inline-chat-transparent';
-
-	constructor(
-		private readonly _editor: ICodeEditor,
-		@IContextKeyService _contextKeyService: IContextKeyService,
-		@IInlineChatService private readonly _inlineChatService: IInlineChatService,
-		@IInlineChatSessionService private readonly _inlineChatSessionService: IInlineChatSessionService,
-		@IConfigurationService private readonly _configurationService: IConfigurationService,
-		@IKeybindingService private readonly _keybindingService: IKeybindingService,
-		@IDebugService private readonly _debugService: IDebugService
-	) {
-		super();
-		this._gutterDecorationTransparent = this._registerGutterDecoration(true);
-		this._gutterDecorationOpaque = this._registerGutterDecoration(false);
-		this._ctxToolbarIconEnabled = CTX_INLINE_CHAT_TOOLBAR_ICON_ENABLED.bindTo(_contextKeyService);
-		this._setToolbarIconEnablementToSetting();
-		this._register(this._configurationService.onDidChangeConfiguration((e: IConfigurationChangeEvent) => {
-			if (e.affectsConfiguration(InlineChatDecorationsContribution.TOOLBAR_SETTING_ID)) {
-				this._setToolbarIconEnablementToSetting();
-				return;
-			}
-			if (!e.affectsConfiguration(InlineChatDecorationsContribution.GUTTER_SETTING_ID)) {
-				return;
-			}
-			this._onEnablementOrModelChanged();
-		}));
-		this._register(this._inlineChatSessionService.onWillStartSession((e) => {
-			if (e === this._editor) {
-				this._hasInlineChatSession = true;
-				this._onEnablementOrModelChanged();
-			}
-		}));
-		this._register(this._inlineChatSessionService.onDidEndSession((e) => {
-			if (e === this._editor) {
-				this._hasInlineChatSession = false;
-				this._onEnablementOrModelChanged();
-			}
-		}));
-		this._register(this._debugService.onWillNewSession((session) => {
-			this._debugSessions.add(session);
-			if (!this._hasActiveDebugSession) {
-				this._hasActiveDebugSession = true;
-				this._onEnablementOrModelChanged();
-			}
-		}));
-		this._register(this._debugService.onDidEndSession((session) => {
-			this._debugSessions.delete(session);
-			if (this._debugSessions.size === 0) {
-				this._hasActiveDebugSession = false;
-				this._onEnablementOrModelChanged();
-			}
-		}));
-		this._register(this._inlineChatService.onDidChangeProviders(() => this._onEnablementOrModelChanged()));
-		this._register(this._editor.onDidChangeModel(() => this._onEnablementOrModelChanged()));
-		this._register(this._keybindingService.onDidUpdateKeybindings(() => {
-			this._updateDecorationHover();
-			this._onEnablementOrModelChanged();
-		}));
-		this._updateDecorationHover();
-		this._onEnablementOrModelChanged();
-	}
-
-	private _setToolbarIconEnablementToSetting(): void {
-		this._ctxToolbarIconEnabled.set(this._configurationService.getValue<boolean>(InlineChatDecorationsContribution.TOOLBAR_SETTING_ID));
-	}
-
-	private _registerGutterDecoration(isTransparent: boolean): ModelDecorationOptions {
-		return ModelDecorationOptions.register({
-			description: 'inline-chat-decoration',
-			glyphMarginClassName: ThemeIcon.asClassName(isTransparent ? GUTTER_INLINE_CHAT_TRANSPARENT_ICON : GUTTER_INLINE_CHAT_OPAQUE_ICON),
-			glyphMargin: { position: GlyphMarginLane.Left },
-			stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
-		});
-	}
-
-	private _updateDecorationHover(): void {
-		const keybinding = this._keybindingService.lookupKeybinding('inlineChat.start')?.getLabel() ?? undefined;
-		if (this._inlineChatKeybinding === keybinding) {
-			return;
-		}
-		this._inlineChatKeybinding = keybinding;
-		const hoverMessage = new MarkdownString(keybinding ? localize('runWithKeybinding', 'Start Inline Chat [{0}]', keybinding) : LOCALIZED_START_INLINE_CHAT_STRING);
-		this._gutterDecorationTransparent.glyphMarginHoverMessage = hoverMessage;
-		this._gutterDecorationOpaque.glyphMarginHoverMessage = hoverMessage;
-	}
-
-	private _updateCurrentBreakpoints(uri: URI) {
-		this._currentBreakpoints = this._debugService.getModel().getBreakpoints({ uri });
-	}
-
-	private _onEnablementOrModelChanged(): void {
-		// cancels the scheduler, removes editor listeners / removes decoration
-		this._localToDispose.clear();
-		if (!this._editor.hasModel() || this._hasActiveDebugSession || this._hasInlineChatSession || this._showGutterIconMode() === ShowGutterIcon.Never || !this._hasProvider()) {
-			return;
-		}
-		const editor = this._editor;
-		const decorationUpdateScheduler = new RunOnceScheduler(() => this._onSelectionOrContentChanged(editor), 100);
-		this._localToDispose.add(decorationUpdateScheduler);
-		this._localToDispose.add(this._debugService.getModel().onDidChangeBreakpoints(() => {
-			this._updateCurrentBreakpoints(editor.getModel().uri);
-			decorationUpdateScheduler.schedule();
-		}));
-		this._localToDispose.add(this._editor.onDidChangeCursorSelection(() => decorationUpdateScheduler.schedule()));
-		this._localToDispose.add(this._editor.onDidChangeModelContent(() => decorationUpdateScheduler.schedule()));
-		this._localToDispose.add(this._editor.onMouseDown(async (e: IEditorMouseEvent) => {
-			const showGutterIconMode = this._showGutterIconMode();
-			const gutterDecorationClassName = showGutterIconMode === ShowGutterIcon.Always ?
-				InlineChatDecorationsContribution.GUTTER_ICON_OPAQUE_CLASSNAME :
-				(showGutterIconMode === ShowGutterIcon.MouseOver ?
-					InlineChatDecorationsContribution.GUTTER_ICON_TRANSPARENT_CLASSNAME : undefined);
-			if (!gutterDecorationClassName || !e.target.element?.classList.contains(gutterDecorationClassName)) {
-				return;
-			}
-			InlineChatController.get(this._editor)?.run();
-		}));
-		this._localToDispose.add({
-			dispose: () => {
-				if (this._gutterDecorationID) {
-					this._removeGutterDecoration(this._gutterDecorationID);
-				}
-			}
-		});
-		this._updateCurrentBreakpoints(editor.getModel().uri);
-		decorationUpdateScheduler.schedule();
-	}
-
-	private _onSelectionOrContentChanged(editor: IActiveCodeEditor): void {
-		const selection = editor.getSelection();
-		const startLineNumber = selection.startLineNumber;
-		const model = editor.getModel();
-
-		let isEnabled = false;
-		const hasBreakpoint = this._currentBreakpoints.some(bp => bp.lineNumber === startLineNumber);
-		if (!hasBreakpoint) {
-			const selectionIsEmpty = selection.isEmpty();
-			if (selectionIsEmpty) {
-				if (/^\s*$/g.test(model.getLineContent(startLineNumber))) {
-					isEnabled = true;
-				}
-			} else {
-				const startPosition = selection.getStartPosition();
-				const endPosition = selection.getEndPosition();
-				const startWord = model.getWordAtPosition(startPosition);
-				const endWord = model.getWordAtPosition(endPosition);
-				const isFirstWordCoveredOrNull = !!startWord ? startPosition.column <= startWord.startColumn : true;
-				const isLastWordCoveredOrNull = !!endWord ? endPosition.column >= endWord.endColumn : true;
-				isEnabled = isFirstWordCoveredOrNull && isLastWordCoveredOrNull;
-			}
-		}
-
-		if (isEnabled) {
-			if (this._gutterDecorationID === undefined) {
-				this._addGutterDecoration(startLineNumber);
-			} else {
-				const decorationRange = model.getDecorationRange(this._gutterDecorationID);
-				if (decorationRange?.startLineNumber !== startLineNumber) {
-					this._updateGutterDecoration(this._gutterDecorationID, startLineNumber);
-				}
-			}
-		} else if (this._gutterDecorationID) {
-			this._removeGutterDecoration(this._gutterDecorationID);
-		}
-	}
-
-	private _showGutterIconMode(): ShowGutterIcon {
-		return this._configurationService.getValue<ShowGutterIcon>(InlineChatDecorationsContribution.GUTTER_SETTING_ID);
-	}
-
-	private _hasProvider(): boolean {
-		return !Iterable.isEmpty(this._inlineChatService.getAllProvider());
-	}
-
-	private _addGutterDecoration(lineNumber: number) {
-		this._editor.changeDecorations((accessor: IModelDecorationsChangeAccessor) => {
-			const showGutterIconMode = this._showGutterIconMode();
-			if (showGutterIconMode === ShowGutterIcon.Never) {
-				return;
-			}
-			this._gutterDecorationID = accessor.addDecoration(new Range(lineNumber, 0, lineNumber, 0), showGutterIconMode === ShowGutterIcon.Always ? this._gutterDecorationOpaque : this._gutterDecorationTransparent);
-		});
-	}
-
-	private _removeGutterDecoration(decorationId: string) {
-		this._editor.changeDecorations((accessor: IModelDecorationsChangeAccessor) => {
-			accessor.removeDecoration(decorationId);
-		});
-		this._gutterDecorationID = undefined;
-	}
-
-	private _updateGutterDecoration(decorationId: string, lineNumber: number) {
-		this._editor.changeDecorations((accessor: IModelDecorationsChangeAccessor) => {
-			accessor.changeDecoration(decorationId, new Range(lineNumber, 0, lineNumber, 0));
-		});
-	}
-
-	override dispose() {
-		super.dispose();
-		this._localToDispose.dispose();
-	}
-}
-
-GutterActionsRegistry.registerGutterActionsGenerator(({ lineNumber, editor, accessor }, result) => {
-	const inlineChatService = accessor.get(IInlineChatService);
-	const noProviders = Iterable.isEmpty(inlineChatService.getAllProvider());
-	if (noProviders) {
-		return;
-	}
-	const preferencesService = accessor.get(IPreferencesService);
-	result.push(new Action(
-		'inlineChat.configureShowGutterIcon',
-		localize('configureShowGutterIcon', "Configure Inline Chat Icon"),
-		undefined,
-		true,
-		() => { preferencesService.openUserSettings({ query: 'inlineChat.showGutterIcon' }); }
-	));
-});
diff --git a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatLivePreviewWidget.ts b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatLivePreviewWidget.ts
index c9b2ce8f926..f4badff7d4d 100644
--- a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatLivePreviewWidget.ts
+++ b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatLivePreviewWidget.ts
@@ -8,7 +8,7 @@ import { DisposableStore, MutableDisposable } from 'vs/base/common/lifecycle';
 import { assertType } from 'vs/base/common/types';
 import { ICodeEditor } from 'vs/editor/browser/editorBrowser';
 import { EmbeddedCodeEditorWidget, EmbeddedDiffEditorWidget } from 'vs/editor/browser/widget/embeddedCodeEditorWidget';
-import { EditorOption } from 'vs/editor/common/config/editorOptions';
+import { EditorOption, IDiffEditorOptions } from 'vs/editor/common/config/editorOptions';
 import { Range } from 'vs/editor/common/core/range';
 import { IModelDecorationOptions, ITextModel } from 'vs/editor/common/model';
 import { ZoneWidget } from 'vs/editor/contrib/zoneWidget/browser/zoneWidget';
@@ -60,6 +60,7 @@ export class InlineChatLivePreviewWidget extends ZoneWidget {
 	constructor(
 		editor: ICodeEditor,
 		private readonly _session: Session,
+		options: IDiffEditorOptions,
 		onDidChangeDiff: (() => void) | undefined,
 		@IInstantiationService instantiationService: IInstantiationService,
 		@IThemeService themeService: IThemeService,
@@ -95,6 +96,7 @@ export class InlineChatLivePreviewWidget extends ZoneWidget {
 			useInlineViewWhenSpaceIsLimited: false,
 			overflowWidgetsDomNode: editor.getOverflowWidgetsDomNode(),
 			onlyShowAccessibleDiffViewer: this.accessibilityService.isScreenReaderOptimized(),
+			...options
 		}, {
 			originalEditor: { contributions: diffContributions },
 			modifiedEditor: { contributions: diffContributions }
diff --git a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatSession.ts b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatSession.ts
index 8dd5e4ffca7..057367761db 100644
--- a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatSession.ts
+++ b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatSession.ts
@@ -7,8 +7,8 @@ import { URI } from 'vs/base/common/uri';
 import { Emitter, Event } from 'vs/base/common/event';
 import { ResourceEdit, ResourceFileEdit, ResourceTextEdit } from 'vs/editor/browser/services/bulkEditService';
 import { IWorkspaceTextEdit, TextEdit, WorkspaceEdit } from 'vs/editor/common/languages';
-import { IModelDeltaDecoration, ITextModel } from 'vs/editor/common/model';
-import { EditMode, IInlineChatSessionProvider, IInlineChatSession, IInlineChatBulkEditResponse, IInlineChatEditResponse, IInlineChatMessageResponse, IInlineChatResponse, IInlineChatService, InlineChatResponseType, InlineChateResponseTypes } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
+import { IModelDecorationOptions, IModelDeltaDecoration, ITextModel } from 'vs/editor/common/model';
+import { EditMode, IInlineChatSessionProvider, IInlineChatSession, IInlineChatBulkEditResponse, IInlineChatEditResponse, IInlineChatResponse, IInlineChatService, InlineChatResponseType, InlineChatResponseTypes } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
 import { IRange, Range } from 'vs/editor/common/core/range';
 import { IActiveCodeEditor, ICodeEditor } from 'vs/editor/browser/editorBrowser';
 import { createDecorator } from 'vs/platform/instantiation/common/instantiation';
@@ -16,7 +16,7 @@ import { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';
 import { IModelService } from 'vs/editor/common/services/model';
 import { ITextModelService } from 'vs/editor/common/services/resolverService';
 import { DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';
-import { createTextBufferFactoryFromSnapshot } from 'vs/editor/common/model/textModel';
+import { ModelDecorationOptions, createTextBufferFactoryFromSnapshot } from 'vs/editor/common/model/textModel';
 import { ILogService } from 'vs/platform/log/common/log';
 import { CancellationToken } from 'vs/base/common/cancellation';
 import { Iterable } from 'vs/base/common/iterator';
@@ -24,7 +24,7 @@ import { toErrorMessage } from 'vs/base/common/errorMessage';
 import { isCancellationError } from 'vs/base/common/errors';
 import { EditOperation, ISingleEditOperation } from 'vs/editor/common/core/editOperation';
 import { raceCancellation } from 'vs/base/common/async';
-import { LineRangeMapping } from 'vs/editor/common/diff/rangeMapping';
+import { DetailedLineRangeMapping, LineRangeMapping } from 'vs/editor/common/diff/rangeMapping';
 import { IMarkdownString } from 'vs/base/common/htmlContent';
 import { IUntitledTextEditorModel } from 'vs/workbench/services/untitled/common/untitledTextEditorModel';
 import { ITextFileService } from 'vs/workbench/services/textfile/common/textfiles';
@@ -71,12 +71,12 @@ export enum ExpansionState {
 
 class SessionWholeRange {
 
-	private static readonly _options = { description: 'inlineChat/session/wholeRange' };
+	private static readonly _options: IModelDecorationOptions = ModelDecorationOptions.register({ description: 'inlineChat/session/wholeRange' });
 
 	private readonly _onDidChange = new Emitter<this>();
 	readonly onDidChange: Event<this> = this._onDidChange.event;
 
-	private readonly _decorationIds: string[] = [];
+	private _decorationIds: string[] = [];
 
 	constructor(private readonly _textModel: ITextModel, wholeRange: IRange) {
 		this._decorationIds = _textModel.deltaDecorations([], [{ range: wholeRange, options: SessionWholeRange._options }]);
@@ -98,6 +98,27 @@ class SessionWholeRange {
 		this._onDidChange.fire(this);
 	}
 
+	fixup(changes: readonly DetailedLineRangeMapping[]): void {
+
+		const newDeco: IModelDeltaDecoration[] = [];
+		for (const { modified } of changes) {
+			const modifiedRange = modified.isEmpty
+				? new Range(modified.startLineNumber, 1, modified.startLineNumber, this._textModel.getLineLength(modified.startLineNumber))
+				: new Range(modified.startLineNumber, 1, modified.endLineNumberExclusive - 1, this._textModel.getLineLength(modified.endLineNumberExclusive - 1));
+
+			newDeco.push({ range: modifiedRange, options: SessionWholeRange._options });
+		}
+		const [first, ...rest] = this._decorationIds; // first is the original whole range
+		const newIds = this._textModel.deltaDecorations(rest, newDeco);
+		this._decorationIds = [first].concat(newIds);
+		this._onDidChange.fire(this);
+	}
+
+	get trackedInitialRange(): Range {
+		const [first] = this._decorationIds;
+		return this._textModel.getDecorationRange(first) ?? new Range(1, 1, 1, 1);
+	}
+
 	get value(): Range {
 		let result: Range | undefined;
 		for (const id of this._decorationIds) {
@@ -140,6 +161,7 @@ export class Session {
 			extension: provider.debugName,
 			startTime: this._startTime.toISOString(),
 			edits: false,
+			finishedByEdit: false,
 			rounds: '',
 			undos: '',
 			editMode
@@ -290,10 +312,10 @@ export class ReplyResponse {
 	readonly untitledTextModel: IUntitledTextEditorModel | undefined;
 	readonly workspaceEdit: WorkspaceEdit | undefined;
 
-	readonly responseType: InlineChateResponseTypes;
+	readonly responseType: InlineChatResponseTypes;
 
 	constructor(
-		readonly raw: IInlineChatBulkEditResponse | IInlineChatEditResponse | IInlineChatMessageResponse,
+		readonly raw: IInlineChatBulkEditResponse | IInlineChatEditResponse,
 		readonly mdContent: IMarkdownString,
 		localUri: URI,
 		readonly modelAltVersionId: number,
@@ -311,7 +333,6 @@ export class ReplyResponse {
 			//
 			editsMap.get(localUri)!.push(raw.edits);
 
-
 		} else if (raw.type === InlineChatResponseType.BulkEdit) {
 			//
 			const edits = ResourceEdit.convert(raw.edits);
@@ -336,21 +357,20 @@ export class ReplyResponse {
 			}
 		}
 
-		if (editsMap.size === 0) {
-			this.responseType = InlineChateResponseTypes.OnlyMessages;
-		} else if (editsMap.size === 1 && editsMap.has(localUri)) {
-			this.responseType = InlineChateResponseTypes.OnlyEdits;
-		} else {
-			this.responseType = InlineChateResponseTypes.Mixed;
-		}
-
 		let needsWorkspaceEdit = false;
 
 		for (const [uri, edits] of editsMap) {
 
-			needsWorkspaceEdit = needsWorkspaceEdit || (uri.scheme !== Schemas.untitled && !isEqual(uri, localUri));
+			const flatEdits = edits.flat();
+			if (flatEdits.length === 0) {
+				editsMap.delete(uri);
+				continue;
+			}
+
+			const isLocalUri = isEqual(uri, localUri);
+			needsWorkspaceEdit = needsWorkspaceEdit || (uri.scheme !== Schemas.untitled && !isLocalUri);
 
-			if (uri.scheme === Schemas.untitled && !this.untitledTextModel) { //TODO@jrieken the first untitled model WINS
+			if (uri.scheme === Schemas.untitled && !isLocalUri && !this.untitledTextModel) { //TODO@jrieken the first untitled model WINS
 				const langSelection = this._languageService.createByFilepathOrFirstLine(uri, undefined);
 				const untitledTextModel = this._textFileService.untitled.create({
 					associatedResource: uri,
@@ -360,7 +380,7 @@ export class ReplyResponse {
 
 				untitledTextModel.resolve().then(async () => {
 					const model = untitledTextModel.textEditorModel!;
-					model.applyEdits(edits.flat().map(edit => EditOperation.replace(Range.lift(edit.range), edit.text)));
+					model.applyEdits(flatEdits.map(edit => EditOperation.replace(Range.lift(edit.range), edit.text)));
 				});
 			}
 		}
@@ -376,6 +396,19 @@ export class ReplyResponse {
 			}
 			this.workspaceEdit = { edits: workspaceEdits };
 		}
+
+
+		const hasEdits = editsMap.size > 0;
+		const hasMessage = mdContent.value.length > 0;
+		if (hasEdits && hasMessage) {
+			this.responseType = InlineChatResponseTypes.Mixed;
+		} else if (hasEdits) {
+			this.responseType = InlineChatResponseTypes.OnlyEdits;
+		} else if (hasMessage) {
+			this.responseType = InlineChatResponseTypes.OnlyMessages;
+		} else {
+			this.responseType = InlineChatResponseTypes.Empty;
+		}
 	}
 }
 
@@ -490,8 +523,6 @@ export class InlineChatSessionService implements IInlineChatSessionService {
 			wholeRange = raw.wholeRange ? Range.lift(raw.wholeRange) : editor.getSelection();
 		}
 
-		// expand to whole lines
-		wholeRange = new Range(wholeRange.startLineNumber, 1, wholeRange.endLineNumber, textModel.getLineMaxColumn(wholeRange.endLineNumber));
 
 		// install managed-marker for the decoration range
 		const wholeRangeMgr = new SessionWholeRange(textModel, wholeRange);
diff --git a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatStrategies.ts b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatStrategies.ts
index e6a06643267..19271f41b6e 100644
--- a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatStrategies.ts
+++ b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatStrategies.ts
@@ -5,38 +5,73 @@
 
 import { disposableWindowInterval } from 'vs/base/browser/dom';
 import { $window } from 'vs/base/browser/window';
-import { equals, tail } from 'vs/base/common/arrays';
+import { IAction, toAction } from 'vs/base/common/actions';
+import { coalesceInPlace, equals, tail } from 'vs/base/common/arrays';
 import { AsyncIterableObject, AsyncIterableSource } from 'vs/base/common/async';
 import { CancellationToken } from 'vs/base/common/cancellation';
-import { Event } from 'vs/base/common/event';
+import { Codicon } from 'vs/base/common/codicons';
+import { Emitter, Event } from 'vs/base/common/event';
+import { Iterable } from 'vs/base/common/iterator';
 import { Lazy } from 'vs/base/common/lazy';
-import { DisposableStore, IDisposable } from 'vs/base/common/lifecycle';
-import { ICodeEditor } from 'vs/editor/browser/editorBrowser';
+import { DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';
+import { ThemeIcon, themeColorFromId } from 'vs/base/common/themables';
+import { ICodeEditor, IViewZone, IViewZoneChangeAccessor } from 'vs/editor/browser/editorBrowser';
 import { IBulkEditService } from 'vs/editor/browser/services/bulkEditService';
+import { StableEditorScrollState } from 'vs/editor/browser/stableEditorScroll';
+import { LineSource, RenderOptions, renderLines } from 'vs/editor/browser/widget/diffEditor/components/diffEditorViewZones/renderLines';
 import { EditOperation, ISingleEditOperation } from 'vs/editor/common/core/editOperation';
+import { LineRange } from 'vs/editor/common/core/lineRange';
 import { Position } from 'vs/editor/common/core/position';
-import { IRange } from 'vs/editor/common/core/range';
+import { IRange, Range } from 'vs/editor/common/core/range';
 import { Selection } from 'vs/editor/common/core/selection';
-import { LineRangeMapping } from 'vs/editor/common/diff/rangeMapping';
+import { DetailedLineRangeMapping, LineRangeMapping, RangeMapping } from 'vs/editor/common/diff/rangeMapping';
 import { IEditorDecorationsCollection } from 'vs/editor/common/editorCommon';
 import { TextEdit } from 'vs/editor/common/languages';
-import { ICursorStateComputer, IIdentifiedSingleEditOperation, IModelDecorationOptions, IModelDeltaDecoration, ITextModel, IValidEditOperation, TrackedRangeStickiness } from 'vs/editor/common/model';
+import { ICursorStateComputer, IIdentifiedSingleEditOperation, IModelDecorationsChangeAccessor, IModelDeltaDecoration, ITextModel, IValidEditOperation, OverviewRulerLane, TrackedRangeStickiness } from 'vs/editor/common/model';
+import { ModelDecorationOptions } from 'vs/editor/common/model/textModel';
 import { IEditorWorkerService } from 'vs/editor/common/services/editorWorker';
+import { InlineDecoration, InlineDecorationType } from 'vs/editor/common/viewModel';
 import { localize } from 'vs/nls';
-import { IConfigurationService } from 'vs/platform/configuration/common/configuration';
 import { IContextKey, IContextKeyService } from 'vs/platform/contextkey/common/contextkey';
 import { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';
+import { IProgress, Progress } from 'vs/platform/progress/common/progress';
 import { IStorageService } from 'vs/platform/storage/common/storage';
 import { SaveReason } from 'vs/workbench/common/editor';
 import { countWords, getNWords } from 'vs/workbench/contrib/chat/common/chatWordCounter';
 import { InlineChatFileCreatePreviewWidget, InlineChatLivePreviewWidget } from 'vs/workbench/contrib/inlineChat/browser/inlineChatLivePreviewWidget';
 import { ReplyResponse, Session } from 'vs/workbench/contrib/inlineChat/browser/inlineChatSession';
-import { InlineChatWidget } from 'vs/workbench/contrib/inlineChat/browser/inlineChatWidget';
-import { CTX_INLINE_CHAT_DOCUMENT_CHANGED } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
+import { InlineChatZoneWidget } from 'vs/workbench/contrib/inlineChat/browser/inlineChatWidget';
+import { CTX_INLINE_CHAT_CHANGE_HAS_DIFF, CTX_INLINE_CHAT_CHANGE_SHOWS_DIFF, CTX_INLINE_CHAT_DOCUMENT_CHANGED, overviewRulerInlineChatDiffInserted } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
 
 export abstract class EditModeStrategy {
 
-	abstract dispose(): void;
+	protected static _decoBlock = ModelDecorationOptions.register({
+		description: 'inline-chat',
+		showIfCollapsed: false,
+		isWholeLine: true,
+		className: 'inline-chat-block-selection',
+	});
+
+
+	protected readonly _onDidAccept = new Emitter<void>();
+	protected readonly _onDidDiscard = new Emitter<void>();
+
+	readonly onDidAccept: Event<void> = this._onDidAccept.event;
+	readonly onDidDiscard: Event<void> = this._onDidDiscard.event;
+
+	toggleDiff?: () => any;
+
+	constructor(
+		protected readonly _session: Session,
+		protected readonly _zone: InlineChatZoneWidget,
+	) { }
+
+	dispose(): void {
+		this._onDidAccept.dispose();
+		this._onDidDiscard.dispose();
+	}
+
+	abstract start(): Promise<void>;
 
 	abstract apply(): Promise<void>;
 
@@ -48,11 +83,16 @@ export abstract class EditModeStrategy {
 
 	abstract undoChanges(altVersionId: number): Promise<void>;
 
-	abstract renderChanges(response: ReplyResponse): Promise<void>;
+	abstract renderChanges(response: ReplyResponse): Promise<Position | undefined>;
 
 	abstract hasFocus(): boolean;
 
-	abstract needsMargin(): boolean;
+	getWholeRangeDecoration(): IModelDeltaDecoration[] {
+		const ranges = [this._session.wholeRange.value];
+		const newDecorations = ranges.map(range => range.isEmpty() ? undefined : ({ range, options: EditModeStrategy._decoBlock }));
+		coalesceInPlace(newDecorations);
+		return newDecorations;
+	}
 }
 
 export class PreviewStrategy extends EditModeStrategy {
@@ -61,16 +101,16 @@ export class PreviewStrategy extends EditModeStrategy {
 	private readonly _listener: IDisposable;
 
 	constructor(
-		private readonly _session: Session,
-		private readonly _widget: InlineChatWidget,
+		session: Session,
+		zone: InlineChatZoneWidget,
 		@IContextKeyService contextKeyService: IContextKeyService,
 	) {
-		super();
+		super(session, zone);
 
 		this._ctxDocumentChanged = CTX_INLINE_CHAT_DOCUMENT_CHANGED.bindTo(contextKeyService);
-		this._listener = Event.debounce(_session.textModelN.onDidChangeContent.bind(_session.textModelN), () => { }, 350)(_ => {
-			if (!_session.textModelN.isDisposed() && !_session.textModel0.isDisposed()) {
-				this._ctxDocumentChanged.set(_session.hasChangedText);
+		this._listener = Event.debounce(session.textModelN.onDidChangeContent.bind(session.textModelN), () => { }, 350)(_ => {
+			if (!session.textModelN.isDisposed() && !session.textModel0.isDisposed()) {
+				this._ctxDocumentChanged.set(session.hasChangedText);
 			}
 		});
 	}
@@ -78,6 +118,11 @@ export class PreviewStrategy extends EditModeStrategy {
 	override dispose(): void {
 		this._listener.dispose();
 		this._ctxDocumentChanged.reset();
+		super.dispose();
+	}
+
+	async start() {
+		// nothing to do
 	}
 
 	async apply() {
@@ -118,142 +163,64 @@ export class PreviewStrategy extends EditModeStrategy {
 		// nothing to do
 	}
 
-	override async renderChanges(response: ReplyResponse): Promise<void> {
+	override async renderChanges(response: ReplyResponse): Promise<undefined> {
 		if (response.allLocalEdits.length > 0) {
 			const allEditOperation = response.allLocalEdits.map(edits => edits.map(TextEdit.asEditOperation));
-			await this._widget.showEditsPreview(this._session.textModel0, this._session.textModelN, allEditOperation);
+			await this._zone.widget.showEditsPreview(this._session.textModel0, this._session.textModelN, allEditOperation);
 		} else {
-			this._widget.hideEditsPreview();
+			this._zone.widget.hideEditsPreview();
 		}
 
 		if (response.untitledTextModel) {
-			this._widget.showCreatePreview(response.untitledTextModel);
+			this._zone.widget.showCreatePreview(response.untitledTextModel);
 		} else {
-			this._widget.hideCreatePreview();
+			this._zone.widget.hideCreatePreview();
 		}
 	}
 
 	hasFocus(): boolean {
-		return this._widget.hasFocus();
-	}
-
-	needsMargin(): boolean {
-		return true;
+		return this._zone.widget.hasFocus();
 	}
 }
 
-class InlineDiffDecorations {
-
-	private readonly _collection: IEditorDecorationsCollection;
-
-	private _data: { tracking: IModelDeltaDecoration; decorating: IModelDecorationOptions }[] = [];
-	private _visible: boolean = false;
-
-	constructor(editor: ICodeEditor, visible: boolean = false) {
-		this._collection = editor.createDecorationsCollection();
-		this._visible = visible;
-	}
-
-	get visible() {
-		return this._visible;
-	}
-
-	set visible(value: boolean) {
-		this._visible = value;
-		this.update();
-	}
-
-	clear() {
-		this._collection.clear();
-		this._data.length = 0;
-	}
-
-	collectEditOperation(op: IValidEditOperation) {
-		this._data.push(InlineDiffDecorations._asDecorationData(op));
-	}
-
-	update() {
-		this._collection.set(this._data.map(d => {
-			const res = { ...d.tracking };
-			if (this._visible) {
-				res.options = { ...res.options, ...d.decorating };
-			}
-			return res;
-		}));
-	}
-
-	private static _asDecorationData(edit: IValidEditOperation): { tracking: IModelDeltaDecoration; decorating: IModelDecorationOptions } {
-		let content = edit.text;
-		if (content.length > 12) {
-			content = content.substring(0, 12) + '';
-		}
-		const tracking: IModelDeltaDecoration = {
-			range: edit.range,
-			options: {
-				description: 'inline-chat-inline-diff',
-			}
-		};
-
-		const decorating: IModelDecorationOptions = {
-			description: 'inline-chat-inline-diff',
-			className: !edit.range.isEmpty() ? 'inline-chat-lines-inserted-range' : undefined,
-			showIfCollapsed: true,
-			before: {
-				content,
-				inlineClassName: 'inline-chat-lines-deleted-range-inline',
-				attachedData: edit,
-			}
-		};
-
-		return { tracking, decorating };
-	}
-}
 
 export interface ProgressingEditsOptions {
 	duration: number;
 	token: CancellationToken;
 }
 
-export class LiveStrategy extends EditModeStrategy {
-
-	protected _diffEnabled: boolean = false;
-
-	private readonly _inlineDiffDecorations: InlineDiffDecorations;
-	private readonly _store: DisposableStore = new DisposableStore();
+export class LivePreviewStrategy extends EditModeStrategy {
 
+	private readonly _previewZone: Lazy<InlineChatFileCreatePreviewWidget>;
+	private readonly _diffZonePool: InlineChatLivePreviewWidget[] = [];
+	private _currentLineRangeGroups: LineRangeMapping[][] = [];
 	private _editCount: number = 0;
 
 	constructor(
-		protected readonly _session: Session,
-		protected readonly _editor: ICodeEditor,
-		protected readonly _widget: InlineChatWidget,
-		@IConfigurationService configService: IConfigurationService,
-		@IStorageService protected _storageService: IStorageService,
-		@IBulkEditService protected readonly _bulkEditService: IBulkEditService,
-		@IEditorWorkerService protected readonly _editorWorkerService: IEditorWorkerService,
-		@IInstantiationService protected readonly _instaService: IInstantiationService,
+		session: Session,
+		private readonly _editor: ICodeEditor,
+		zone: InlineChatZoneWidget,
+		@IStorageService storageService: IStorageService,
+		@IBulkEditService bulkEditService: IBulkEditService,
+		@IEditorWorkerService private readonly _editorWorkerService: IEditorWorkerService,
+		@IInstantiationService private readonly _instaService: IInstantiationService,
 	) {
-		super();
-		this._diffEnabled = configService.getValue<boolean>('inlineChat.showDiff');
+		super(session, zone);
 
-		this._inlineDiffDecorations = new InlineDiffDecorations(this._editor, this._diffEnabled);
-		this._inlineDiffDecorations.visible = this._diffEnabled;
-
-		this._store.add(configService.onDidChangeConfiguration(e => {
-			if (e.affectsConfiguration('inlineChat.showDiff')) {
-				this._diffEnabled = !this._diffEnabled;
-				this._doToggleDiff();
-			}
-		}));
+		this._previewZone = new Lazy(() => _instaService.createInstance(InlineChatFileCreatePreviewWidget, _editor));
 	}
 
 	override dispose(): void {
-		this._inlineDiffDecorations.clear();
-		this._store.dispose();
+		for (const zone of this._diffZonePool) {
+			zone.hide();
+			zone.dispose();
+		}
+		this._previewZone.rawValue?.hide();
+		this._previewZone.rawValue?.dispose();
+		super.dispose();
 	}
-
-	protected _doToggleDiff(): void {
-		this._inlineDiffDecorations.visible = this._diffEnabled;
+	async start() {
+		// nothing to do
 	}
 
 	async apply() {
@@ -275,15 +242,13 @@ export class LiveStrategy extends EditModeStrategy {
 			return;
 		}
 		const targetAltVersion = textModelNSnapshotAltVersion ?? textModelNAltVersion;
-		LiveStrategy._undoModelUntil(modelN, targetAltVersion);
+		await undoModelUntil(modelN, targetAltVersion);
 	}
-
 	override async makeChanges(edits: ISingleEditOperation[]): Promise<void> {
 		const cursorStateComputerAndInlineDiffCollection: ICursorStateComputer = (undoEdits) => {
 			let last: Position | null = null;
 			for (const edit of undoEdits) {
 				last = !last || last.isBefore(edit.range.getEndPosition()) ? edit.range.getEndPosition() : last;
-				this._inlineDiffDecorations.collectEditOperation(edit);
 			}
 			return last && [Selection.fromPositions(last)];
 		};
@@ -297,7 +262,8 @@ export class LiveStrategy extends EditModeStrategy {
 
 	override async undoChanges(altVersionId: number): Promise<void> {
 		const { textModelN } = this._session;
-		LiveStrategy._undoModelUntil(textModelN, altVersionId);
+		await undoModelUntil(textModelN, altVersionId);
+		await this._updateDiffZones();
 	}
 
 	override async makeProgressiveChanges(edits: ISingleEditOperation[], opts: ProgressingEditsOptions): Promise<void> {
@@ -307,6 +273,13 @@ export class LiveStrategy extends EditModeStrategy {
 			this._editor.pushUndoStop();
 		}
 
+		//add a listener that shows the diff zones as soon as the first edit is applied
+		let renderTask = Promise.resolve();
+		const changeListener = this._session.textModelN.onDidChangeContent(() => {
+			changeListener.dispose();
+			renderTask = this._updateDiffZones();
+		});
+
 		const durationInSec = opts.duration / 1000;
 		for (const edit of edits) {
 			console.log(edit.range.startLineNumber, edit.range.endLineNumber, edit.range.startColumn, edit.range.endColumn, edit.text);
@@ -315,23 +288,19 @@ export class LiveStrategy extends EditModeStrategy {
 			// console.log({ durationInSec, wordCount, speed: wordCount / durationInSec });
 			await performAsyncTextEdit(this._session.textModelN, asProgressiveEdit(edit, speed, opts.token));
 		}
+
+		await renderTask;
+		changeListener.dispose();
 	}
 
-	override async renderChanges(response: ReplyResponse) {
-		const diff = await this._editorWorkerService.computeDiff(this._session.textModel0.uri, this._session.textModelN.uri, { ignoreTrimWhitespace: false, maxComputationTimeMs: 5000, computeMoves: false }, 'advanced');
-		this._updateSummaryMessage(diff?.changes ?? []);
-		this._inlineDiffDecorations.update();
+	override async renderChanges(response: ReplyResponse): Promise<undefined> {
 
-		if (response.untitledTextModel) {
-			this._widget.showCreatePreview(response.untitledTextModel);
-		} else {
-			this._widget.hideCreatePreview();
-		}
-	}
+		await this._updateDiffZones();
 
-	private static _undoModelUntil(model: ITextModel, targetAltVersion: number): void {
-		while (targetAltVersion < model.getAlternativeVersionId() && model.canUndo()) {
-			model.undo();
+		if (response.untitledTextModel && !response.untitledTextModel.isDisposed()) {
+			this._previewZone.value.showCreation(this._session.wholeRange.value.getStartPosition().delta(-1), response.untitledTextModel);
+		} else {
+			this._previewZone.value.hide();
 		}
 	}
 
@@ -348,50 +317,9 @@ export class LiveStrategy extends EditModeStrategy {
 		} else {
 			message = localize('lines.N', "Changed {0} lines", linesChanged);
 		}
-		this._widget.updateStatus(message);
-	}
-
-	override needsMargin(): boolean {
-		return true;
-	}
-
-	hasFocus(): boolean {
-		return this._widget.hasFocus();
-	}
-}
-
-export class LivePreviewStrategy extends LiveStrategy {
-
-	private readonly _previewZone: Lazy<InlineChatFileCreatePreviewWidget>;
-	private readonly _diffZonePool: InlineChatLivePreviewWidget[] = [];
-	private _currentLineRangeGroups: LineRangeMapping[][] = [];
-
-	constructor(
-		session: Session,
-		editor: ICodeEditor,
-		widget: InlineChatWidget,
-		@IConfigurationService configService: IConfigurationService,
-		@IStorageService storageService: IStorageService,
-		@IBulkEditService bulkEditService: IBulkEditService,
-		@IEditorWorkerService editorWorkerService: IEditorWorkerService,
-		@IInstantiationService instaService: IInstantiationService,
-	) {
-		super(session, editor, widget, configService, storageService, bulkEditService, editorWorkerService, instaService);
-
-		this._previewZone = new Lazy(() => instaService.createInstance(InlineChatFileCreatePreviewWidget, editor));
-	}
-
-	override dispose(): void {
-		for (const zone of this._diffZonePool) {
-			zone.hide();
-			zone.dispose();
-		}
-		this._previewZone.rawValue?.hide();
-		this._previewZone.rawValue?.dispose();
-		super.dispose();
+		this._zone.widget.updateStatus(message);
 	}
 
-
 	private async _updateDiffZones() {
 		const diff = await this._editorWorkerService.computeDiff(this._session.textModel0.uri, this._session.textModelN.uri, { ignoreTrimWhitespace: false, maxComputationTimeMs: 5000, computeMoves: false }, 'advanced');
 		if (!diff || diff.changes.length === 0) {
@@ -453,7 +381,7 @@ export class LivePreviewStrategy extends LiveStrategy {
 
 		// create enough zones
 		while (groups.length > this._diffZonePool.length) {
-			this._diffZonePool.push(this._instaService.createInstance(InlineChatLivePreviewWidget, this._editor, this._session, this._diffZonePool.length === 0 ? handleDiff : undefined));
+			this._diffZonePool.push(this._instaService.createInstance(InlineChatLivePreviewWidget, this._editor, this._session, {}, this._diffZonePool.length === 0 ? handleDiff : undefined));
 		}
 		for (let i = 0; i < groups.length; i++) {
 			this._diffZonePool[i].showForChanges(groups[i]);
@@ -464,39 +392,10 @@ export class LivePreviewStrategy extends LiveStrategy {
 		}
 	}
 
-	override async makeProgressiveChanges(edits: ISingleEditOperation[], opts: ProgressingEditsOptions): Promise<void> {
-
-		const changeTask = super.makeProgressiveChanges(edits, opts);
-
-		//add a listener that shows the diff zones as soon as the first edit is applied
-		let renderTask = Promise.resolve();
-		const changeListener = this._session.textModelN.onDidChangeContent(() => {
-			changeListener.dispose();
-			renderTask = this._updateDiffZones();
-		});
-		await changeTask;
-		await renderTask;
-		changeListener.dispose();
-	}
-
-	override async undoChanges(altVersionId: number): Promise<void> {
-		await super.undoChanges(altVersionId);
-		await this._updateDiffZones();
-	}
-
-	override async renderChanges(response: ReplyResponse) {
-
-		await this._updateDiffZones();
-
-		if (response.untitledTextModel && !response.untitledTextModel.isDisposed()) {
-			this._previewZone.value.showCreation(this._session.wholeRange.value.getStartPosition().delta(-1), response.untitledTextModel);
-		} else {
-			this._previewZone.value.hide();
-		}
-	}
-
 	override hasFocus(): boolean {
-		return super.hasFocus() || Boolean(this._previewZone.rawValue?.hasFocus()) || this._diffZonePool.some(zone => zone.isVisible && zone.hasFocus());
+		return this._zone.widget.hasFocus()
+			|| Boolean(this._previewZone.rawValue?.hasFocus())
+			|| this._diffZonePool.some(zone => zone.isVisible && zone.hasFocus());
 	}
 }
 
@@ -505,7 +404,7 @@ export interface AsyncTextEdit {
 	readonly newText: AsyncIterable<string>;
 }
 
-export async function performAsyncTextEdit(model: ITextModel, edit: AsyncTextEdit) {
+export async function performAsyncTextEdit(model: ITextModel, edit: AsyncTextEdit, progress?: IProgress<IValidEditOperation[]>) {
 
 	const [id] = model.deltaDecorations([], [{
 		range: edit.range,
@@ -531,7 +430,10 @@ export async function performAsyncTextEdit(model: ITextModel, edit: AsyncTextEdi
 			? EditOperation.replace(range, part) // first edit needs to override the "anchor"
 			: EditOperation.insert(range.getEndPosition(), part);
 
-		model.pushEditOperations(null, [edit], () => null);
+		model.pushEditOperations(null, [edit], (undoEdits) => {
+			progress?.report(undoEdits);
+			return null;
+		});
 		first = false;
 	}
 }
@@ -576,3 +478,464 @@ export function asProgressiveEdit(edit: IIdentifiedSingleEditOperation, wordsPer
 		newText: stream.asyncIterable
 	};
 }
+
+
+// ---
+
+class Hunk {
+	constructor(
+		readonly original: LineRange,
+		readonly modified: LineRange,
+		readonly changes: RangeMapping[]
+	) { }
+}
+
+export class LiveStrategy extends EditModeStrategy {
+
+	private readonly _decoInsertedText = ModelDecorationOptions.register({
+		description: 'inline-modified-line',
+		className: 'inline-chat-inserted-range-linehighlight',
+		isWholeLine: true,
+		overviewRuler: {
+			position: OverviewRulerLane.Full,
+			color: themeColorFromId(overviewRulerInlineChatDiffInserted),
+		}
+	});
+
+	private readonly _decoInsertedTextRange = ModelDecorationOptions.register({
+		description: 'inline-chat-inserted-range-linehighlight',
+		className: 'inline-chat-inserted-range',
+	});
+
+	private readonly _store: DisposableStore = new DisposableStore();
+	private readonly _renderStore: DisposableStore = new DisposableStore();
+	private readonly _previewZone: Lazy<InlineChatFileCreatePreviewWidget>;
+
+	private readonly _ctxCurrentChangeHasDiff: IContextKey<boolean>;
+	private readonly _ctxCurrentChangeShowsDiff: IContextKey<boolean>;
+
+	private readonly _progressiveEditingDecorations: IEditorDecorationsCollection;
+
+	private _editCount: number = 0;
+
+	constructor(
+		session: Session,
+		protected readonly _editor: ICodeEditor,
+		zone: InlineChatZoneWidget,
+		@IContextKeyService contextKeyService: IContextKeyService,
+		@IEditorWorkerService protected readonly _editorWorkerService: IEditorWorkerService,
+		@IInstantiationService protected readonly _instaService: IInstantiationService,
+	) {
+		super(session, zone);
+		this._ctxCurrentChangeHasDiff = CTX_INLINE_CHAT_CHANGE_HAS_DIFF.bindTo(contextKeyService);
+		this._ctxCurrentChangeShowsDiff = CTX_INLINE_CHAT_CHANGE_SHOWS_DIFF.bindTo(contextKeyService);
+
+		this._progressiveEditingDecorations = this._editor.createDecorationsCollection();
+		this._previewZone = new Lazy(() => _instaService.createInstance(InlineChatFileCreatePreviewWidget, _editor));
+
+	}
+
+	override dispose(): void {
+		this._resetDiff();
+		this._previewZone.rawValue?.dispose();
+		this._store.dispose();
+		super.dispose();
+	}
+
+	private _resetDiff(): void {
+		this._ctxCurrentChangeHasDiff.reset();
+		this._ctxCurrentChangeShowsDiff.reset();
+		this._renderStore.clear();
+		this._zone.widget.updateStatus('');
+		this._progressiveEditingDecorations.clear();
+	}
+
+	async start() {
+		this._resetDiff();
+	}
+
+	async apply() {
+		this._resetDiff();
+		if (this._editCount > 0) {
+			this._editor.pushUndoStop();
+		}
+		if (!(this._session.lastExchange?.response instanceof ReplyResponse)) {
+			return;
+		}
+		const { untitledTextModel } = this._session.lastExchange.response;
+		if (untitledTextModel && !untitledTextModel.isDisposed() && untitledTextModel.isDirty()) {
+			await untitledTextModel.save({ reason: SaveReason.EXPLICIT });
+		}
+	}
+
+	async cancel() {
+		this._resetDiff();
+		const { textModelN: modelN, textModelNAltVersion, textModelNSnapshotAltVersion } = this._session;
+		if (modelN.isDisposed()) {
+			return;
+		}
+		const targetAltVersion = textModelNSnapshotAltVersion ?? textModelNAltVersion;
+		await undoModelUntil(modelN, targetAltVersion);
+	}
+
+	override async undoChanges(altVersionId: number): Promise<void> {
+		this._renderStore.clear();
+
+		const { textModelN } = this._session;
+		await undoModelUntil(textModelN, altVersionId);
+	}
+
+	override async makeChanges(edits: ISingleEditOperation[]): Promise<void> {
+		return this._makeChanges(edits, undefined);
+	}
+
+	override async makeProgressiveChanges(edits: ISingleEditOperation[], opts: ProgressingEditsOptions): Promise<void> {
+		return this._makeChanges(edits, opts);
+	}
+
+	private async _makeChanges(edits: ISingleEditOperation[], opts: ProgressingEditsOptions | undefined): Promise<void> {
+
+		// push undo stop before first edit
+		if (++this._editCount === 1) {
+			this._editor.pushUndoStop();
+		}
+
+		// add decorations once per line that got edited
+		const progress = new Progress<IValidEditOperation[]>(edits => {
+
+			const newLines = new Set<number>();
+			for (const edit of edits) {
+				LineRange.fromRange(edit.range).forEach(line => newLines.add(line));
+			}
+			const existingRanges = this._progressiveEditingDecorations.getRanges().map(LineRange.fromRange);
+			for (const existingRange of existingRanges) {
+				existingRange.forEach(line => newLines.delete(line));
+			}
+			const newDecorations: IModelDeltaDecoration[] = [];
+			for (const line of newLines) {
+				newDecorations.push({ range: new Range(line, 1, line, Number.MAX_VALUE), options: this._decoInsertedText });
+			}
+
+			this._progressiveEditingDecorations.append(newDecorations);
+		});
+
+		if (opts) {
+			// ASYNC
+			const durationInSec = opts.duration / 1000;
+			for (const edit of edits) {
+				const wordCount = countWords(edit.text ?? '');
+				const speed = wordCount / durationInSec;
+				// console.log({ durationInSec, wordCount, speed: wordCount / durationInSec });
+				await performAsyncTextEdit(this._session.textModelN, asProgressiveEdit(edit, speed, opts.token), progress);
+			}
+
+		} else {
+			// SYNC
+			this._editor.executeEdits('inline-chat-live', edits, undoEdits => {
+				progress.report(undoEdits);
+				return null;
+			});
+		}
+	}
+
+	override async renderChanges(response: ReplyResponse) {
+
+		if (response.untitledTextModel && !response.untitledTextModel.isDisposed()) {
+			this._previewZone.value.showCreation(this._session.wholeRange.value.getStartPosition().delta(-1), response.untitledTextModel);
+		} else {
+			this._previewZone.value.hide();
+		}
+
+		this._progressiveEditingDecorations.clear();
+
+		const hunks = await this._computeHunks();
+
+		this._renderStore.clear();
+
+		if (hunks.length === 0) {
+			return undefined;
+		}
+
+		const enum HunkState {
+			Accepted = 1,
+			Rejected = 2,
+		}
+
+		type HunkDisplayData = {
+			acceptedOrRejected: HunkState | undefined;
+			decorationIds: string[];
+
+			viewZoneId: string | undefined;
+			viewZone: IViewZone;
+
+			distance: number;
+			position: Position;
+			actions: IAction[];
+			toggleDiff?: () => any;
+		};
+
+		let widgetData: HunkDisplayData | undefined;
+		const hunkDisplayData = new Map<Hunk, HunkDisplayData>();
+
+		const renderHunks = () => {
+
+			changeDecorationsAndViewZones(this._editor, (decorationsAccessor, viewZoneAccessor) => {
+
+				widgetData = undefined;
+
+				for (const hunk of hunks) {
+
+					const { modified } = hunk;
+
+					let data = hunkDisplayData.get(hunk);
+					if (!data) {
+						// first time -> create decoration
+						const decorationIds: string[] = [];
+						const modifiedRange = asRange(modified, this._session.textModelN);
+						decorationIds.push(decorationsAccessor.addDecoration(modifiedRange, this._decoInsertedText));
+						for (const change of hunk.changes) {
+							decorationIds.push(decorationsAccessor.addDecoration(change.modifiedRange, this._decoInsertedTextRange));
+						}
+
+						const actions = [
+							toAction({
+								id: 'accept',
+								label: localize('accept', "Accept"),
+								class: ThemeIcon.asClassName(Codicon.check),
+								run: () => {
+									// ACCEPT: stop rendering this as inserted
+									hunkDisplayData.get(hunk)!.acceptedOrRejected = HunkState.Accepted;
+									renderHunks();
+								}
+							}),
+							toAction({
+								id: 'discard',
+								label: localize('discard', "Discard"),
+								class: ThemeIcon.asClassName(Codicon.discard),
+								run: () => {
+									const edits: ISingleEditOperation[] = [];
+									for (let i = 1; i < decorationIds.length; i++) {
+										// DISCARD: replace modified range with original value. The modified range is retrieved from a decoration
+										// which was created above so that typing in the editor keeps discard working.
+										const modifiedRange = this._session.textModelN.getDecorationRange(decorationIds[i])!;
+										const originalValue = this._session.textModel0.getValueInRange(hunk.changes[i - 1].originalRange);
+										edits.push(EditOperation.replace(modifiedRange, originalValue));
+									}
+									this._session.textModelN.pushEditOperations(null, edits, () => null);
+									hunkDisplayData.get(hunk)!.acceptedOrRejected = HunkState.Rejected;
+									renderHunks();
+								}
+							}),
+						];
+
+						// original view zone
+						const mightContainNonBasicASCII = this._session.textModel0.mightContainNonBasicASCII() ?? false;
+						const mightContainRTL = this._session.textModel0.mightContainRTL() ?? false;
+						const renderOptions = RenderOptions.fromEditor(this._editor);
+						const source = new LineSource(
+							hunk.original.mapToLineArray(l => this._session.textModel0.tokenization.getLineTokens(l)),
+							[],
+							mightContainNonBasicASCII,
+							mightContainRTL,
+						);
+						const domNode = document.createElement('div');
+						domNode.className = 'inline-chat-original-zone2';
+						const result = renderLines(source, renderOptions, [new InlineDecoration(new Range(hunk.original.startLineNumber, 1, hunk.original.startLineNumber, 1), '', InlineDecorationType.Regular)], domNode);
+						const viewZoneData: IViewZone = {
+							afterLineNumber: -1,
+							heightInLines: result.heightInLines,
+							domNode,
+						};
+
+						const toggleDiff = () => {
+							const scrollState = StableEditorScrollState.capture(this._editor);
+							if (!data!.viewZoneId) {
+
+								this._editor.changeViewZones(accessor => {
+									viewZoneData.afterLineNumber = this._session.textModelN.getDecorationRange(decorationIds[0])!.startLineNumber - 1;
+									data!.viewZoneId = accessor.addZone(viewZoneData);
+								});
+								this._ctxCurrentChangeShowsDiff.set(true);
+							} else {
+								this._editor.changeViewZones(accessor => {
+									accessor.removeZone(data!.viewZoneId!);
+									data!.viewZoneId = undefined;
+								});
+								this._ctxCurrentChangeShowsDiff.set(false);
+							}
+							scrollState.restore(this._editor);
+						};
+
+						const zoneLineNumber = this._zone.position!.lineNumber;
+						const myDistance = zoneLineNumber <= modifiedRange.startLineNumber
+							? modifiedRange.startLineNumber - zoneLineNumber
+							: zoneLineNumber - modifiedRange.endLineNumber;
+
+						data = {
+							acceptedOrRejected: undefined,
+							decorationIds,
+							viewZoneId: '',
+							viewZone: viewZoneData,
+							distance: myDistance,
+							position: modifiedRange.getStartPosition().delta(-1),
+							toggleDiff: !hunk.original.isEmpty ? toggleDiff : undefined,
+							actions
+						};
+
+						hunkDisplayData.set(hunk, data);
+
+					} else if (data.acceptedOrRejected !== undefined) {
+						// accepted or rejected -> remove decoration
+						for (const decorationId of data.decorationIds) {
+							decorationsAccessor.removeDecoration(decorationId);
+						}
+						if (data.viewZoneId) {
+							viewZoneAccessor.removeZone(data.viewZoneId);
+						}
+
+						data.decorationIds = [];
+						data.viewZoneId = undefined;
+
+					} else {
+						// update distance and position based on modifiedRange-decoration
+						const zoneLineNumber = this._zone.position!.lineNumber;
+						const modifiedRangeNow = this._session.textModelN.getDecorationRange(data.decorationIds[0])!;
+						data.position = modifiedRangeNow.getStartPosition().delta(-1);
+						data.distance = zoneLineNumber <= modifiedRangeNow.startLineNumber
+							? modifiedRangeNow.startLineNumber - zoneLineNumber
+							: zoneLineNumber - modifiedRangeNow.endLineNumber;
+					}
+
+					if (!data.acceptedOrRejected) {
+						if (!widgetData || data.distance < widgetData.distance) {
+							widgetData = data;
+						}
+					}
+				}
+			});
+
+			if (widgetData) {
+				this._zone.widget.setExtraButtons(widgetData.actions);
+				this._zone.updatePositionAndHeight(widgetData.position);
+				this._editor.revealPositionInCenterIfOutsideViewport(widgetData.position);
+
+				const remainingHunks = Iterable.reduce(hunkDisplayData.values(), (p, c) => { return p + (c.acceptedOrRejected ? 0 : 1); }, 0);
+				this._updateSummaryMessage(remainingHunks);
+
+				this._ctxCurrentChangeHasDiff.set(Boolean(widgetData.toggleDiff));
+				this.toggleDiff = widgetData.toggleDiff;
+
+			} else if (hunkDisplayData.size > 0) {
+				// everything accepted or rejected
+				let oneAccepted = false;
+				for (const data of hunkDisplayData.values()) {
+					if (data.acceptedOrRejected === HunkState.Accepted) {
+						oneAccepted = true;
+						break;
+					}
+				}
+				if (oneAccepted) {
+					this._onDidAccept.fire();
+				} else {
+					this._onDidDiscard.fire();
+				}
+			}
+		};
+
+		renderHunks();
+
+		this._renderStore.add(toDisposable(() => {
+			this._zone.widget.setExtraButtons([]);
+
+			changeDecorationsAndViewZones(this._editor, (decorationsAccessor, viewZoneAccessor) => {
+				for (const data of hunkDisplayData.values()) {
+					// remove decorations
+					for (const decorationId of data.decorationIds) {
+						decorationsAccessor.removeDecoration(decorationId);
+					}
+					// remove view zone
+					if (data.viewZoneId) {
+						viewZoneAccessor.removeZone(data.viewZoneId);
+					}
+					data.viewZone.domNode.remove();
+				}
+			});
+		}));
+
+
+		return widgetData?.position;
+	}
+
+	private static readonly HUNK_THRESHOLD = 8;
+
+	private async _computeHunks(): Promise<Hunk[]> {
+		const diff = await this._editorWorkerService.computeDiff(this._session.textModel0.uri, this._session.textModelN.uri, { ignoreTrimWhitespace: false, maxComputationTimeMs: Number.MAX_SAFE_INTEGER, computeMoves: false }, 'advanced');
+
+		if (!diff || diff.changes.length === 0) {
+			return [];
+		}
+
+		// merge changes neighboring changes
+		const mergedChanges = [diff.changes[0]];
+		for (let i = 1; i < diff.changes.length; i++) {
+			const lastChange = mergedChanges[mergedChanges.length - 1];
+			const thisChange = diff.changes[i];
+			if (thisChange.modified.startLineNumber - lastChange.modified.endLineNumberExclusive <= LiveStrategy.HUNK_THRESHOLD) {
+				mergedChanges[mergedChanges.length - 1] = new DetailedLineRangeMapping(
+					lastChange.original.join(thisChange.original),
+					lastChange.modified.join(thisChange.modified),
+					(lastChange.innerChanges ?? []).concat(thisChange.innerChanges ?? [])
+				);
+			} else {
+				mergedChanges.push(thisChange);
+			}
+		}
+
+		return mergedChanges.map(change => new Hunk(change.original, change.modified, change.innerChanges ?? []));
+	}
+
+
+	protected _updateSummaryMessage(hunkCount: number) {
+		let message: string;
+		if (hunkCount === 0) {
+			message = localize('change.0', "Nothing changed");
+		} else if (hunkCount === 1) {
+			message = localize('change.1', "1 change");
+		} else {
+			message = localize('lines.NM', "{0} changes", hunkCount);
+		}
+		this._zone.widget.updateStatus(message);
+	}
+
+	hasFocus(): boolean {
+		return this._zone.widget.hasFocus();
+	}
+
+	override getWholeRangeDecoration(): IModelDeltaDecoration[] {
+		// don't render the blue in live mode
+		return [];
+	}
+}
+
+
+async function undoModelUntil(model: ITextModel, targetAltVersion: number): Promise<void> {
+	while (targetAltVersion < model.getAlternativeVersionId() && model.canUndo()) {
+		await model.undo();
+	}
+}
+
+
+function asRange(lineRange: LineRange, model: ITextModel): Range {
+	return lineRange.isEmpty
+		? new Range(lineRange.startLineNumber, 1, lineRange.startLineNumber, model.getLineLength(lineRange.startLineNumber))
+		: new Range(lineRange.startLineNumber, 1, lineRange.endLineNumberExclusive - 1, model.getLineLength(lineRange.endLineNumberExclusive - 1));
+}
+
+
+function changeDecorationsAndViewZones(editor: ICodeEditor, callback: (accessor: IModelDecorationsChangeAccessor, viewZoneAccessor: IViewZoneChangeAccessor) => void): void {
+	editor.changeDecorations(decorationsAccessor => {
+		editor.changeViewZones(viewZoneAccessor => {
+			callback(decorationsAccessor, viewZoneAccessor);
+		});
+	});
+}
diff --git a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatWidget.ts b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatWidget.ts
index f868fdeb93d..beacd0fdcf4 100644
--- a/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatWidget.ts
+++ b/src/vs/workbench/contrib/inlineCSChat/browser/inlineCSChatWidget.ts
@@ -12,9 +12,9 @@ import { localize } from 'vs/nls';
 import { IContextKey, IContextKeyService } from 'vs/platform/contextkey/common/contextkey';
 import { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';
 import { ZoneWidget } from 'vs/editor/contrib/zoneWidget/browser/zoneWidget';
-import { CTX_INLINE_CHAT_FOCUSED, CTX_INLINE_CHAT_EMPTY, CTX_INLINE_CHAT_OUTER_CURSOR_POSITION, CTX_INLINE_CHAT_VISIBLE, MENU_INLINE_CHAT_WIDGET, MENU_INLINE_CHAT_WIDGET_STATUS, MENU_INLINE_CHAT_WIDGET_MARKDOWN_MESSAGE, CTX_INLINE_CHAT_MESSAGE_CROP_STATE, IInlineChatSlashCommand, MENU_INLINE_CHAT_WIDGET_FEEDBACK, ACTION_REGENERATE_RESPONSE, ACTION_VIEW_IN_CHAT, MENU_INLINE_CHAT_WIDGET_TOGGLE, CTX_INLINE_CHAT_INNER_CURSOR_FIRST, CTX_INLINE_CHAT_INNER_CURSOR_LAST, CTX_INLINE_CHAT_INNER_CURSOR_START, CTX_INLINE_CHAT_INNER_CURSOR_END, CTX_INLINE_CHAT_RESPONSE_FOCUSED } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
+import { CTX_INLINE_CHAT_FOCUSED, CTX_INLINE_CHAT_EMPTY, CTX_INLINE_CHAT_OUTER_CURSOR_POSITION, CTX_INLINE_CHAT_VISIBLE, MENU_INLINE_CHAT_INPUT, MENU_INLINE_CHAT_WIDGET_STATUS, MENU_INLINE_CHAT_WIDGET_MARKDOWN_MESSAGE, CTX_INLINE_CHAT_MESSAGE_CROP_STATE, IInlineChatSlashCommand, MENU_INLINE_CHAT_WIDGET_FEEDBACK, ACTION_REGENERATE_RESPONSE, ACTION_VIEW_IN_CHAT, CTX_INLINE_CHAT_INNER_CURSOR_FIRST, CTX_INLINE_CHAT_INNER_CURSOR_LAST, CTX_INLINE_CHAT_INNER_CURSOR_START, CTX_INLINE_CHAT_INNER_CURSOR_END, CTX_INLINE_CHAT_RESPONSE_FOCUSED, ACTION_ACCEPT_CHANGES, MENU_INLINE_CHAT_WIDGET } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
 import { IModelDeltaDecoration, ITextModel } from 'vs/editor/common/model';
-import { EventType, Dimension, addDisposableListener, getActiveElement, getTotalHeight, getTotalWidth, h, reset, getWindow } from 'vs/base/browser/dom';
+import { Dimension, addDisposableListener, getActiveElement, getTotalHeight, getTotalWidth, h, reset } from 'vs/base/browser/dom';
 import { Emitter, Event, MicrotaskEmitter } from 'vs/base/common/event';
 import { IEditorConstructionOptions } from 'vs/editor/browser/config/editorConfiguration';
 import { ICodeEditorWidgetOptions } from 'vs/editor/browser/widget/codeEditorWidget';
@@ -46,30 +46,28 @@ import { AccessibilityVerbositySettingId } from 'vs/workbench/contrib/accessibil
 import { renderLabelWithIcons } from 'vs/base/browser/ui/iconLabel/iconLabels';
 import { ExpansionState } from 'vs/workbench/contrib/inlineChat/browser/inlineChatSession';
 import * as aria from 'vs/base/browser/ui/aria/aria';
-import { IMenuWorkbenchButtonBarOptions, MenuWorkbenchButtonBar } from 'vs/platform/actions/browser/buttonbar';
+import { IWorkbenchButtonBarOptions, MenuWorkbenchButtonBar, WorkbenchButtonBar } from 'vs/platform/actions/browser/buttonbar';
 import { SlashCommandContentWidget } from 'vs/workbench/contrib/chat/browser/chatSlashCommandContentWidget';
-import { IContextMenuService } from 'vs/platform/contextview/browser/contextView';
 import { IAccessibleViewService } from 'vs/workbench/contrib/accessibility/browser/accessibleView';
-import { StandardMouseEvent } from 'vs/base/browser/mouseEvent';
 import { AccessibilityCommandId } from 'vs/workbench/contrib/accessibility/common/accessibilityCommands';
 import { assertType } from 'vs/base/common/types';
 import { renderFormattedText } from 'vs/base/browser/formattedTextRenderer';
 import { IMarkdownString, MarkdownString } from 'vs/base/common/htmlContent';
-import { MarkdownRenderer } from 'vs/editor/contrib/markdownRenderer/browser/markdownRenderer';
 import { ChatEditorOptions } from 'vs/workbench/contrib/chat/browser/chatOptions';
 import { MenuId } from 'vs/platform/actions/common/actions';
 import { editorForeground, inputBackground, editorBackground } from 'vs/platform/theme/common/colorRegistry';
-import { CodeBlockPart } from 'vs/workbench/contrib/chat/browser/codeBlockPart';
 import { Lazy } from 'vs/base/common/lazy';
 import { IEditorWorkerService } from 'vs/editor/common/services/editorWorker';
 import { ChatResponseViewModel } from 'vs/workbench/contrib/chat/common/chatViewModel';
 import { ChatModel, ChatResponseModel } from 'vs/workbench/contrib/chat/common/chatModel';
 import { ILogService } from 'vs/platform/log/common/log';
-import { ChatListItemRenderer, IChatListItemRendererOptions, IChatRendererDelegate } from 'vs/workbench/contrib/chat/browser/chatListRenderer'; import { IUntitledTextEditorModel } from 'vs/workbench/services/untitled/common/untitledTextEditorModel';
+import { ChatListItemRenderer, IChatListItemRendererOptions, IChatRendererDelegate } from 'vs/workbench/contrib/chat/browser/chatListRenderer';
+import { IUntitledTextEditorModel } from 'vs/workbench/services/untitled/common/untitledTextEditorModel';
 import { ITextModelService } from 'vs/editor/common/services/resolverService';
 import { IChatReplyFollowup } from 'vs/workbench/contrib/chat/common/chatService';
 import { IChatAgentService } from 'vs/workbench/contrib/chat/common/chatAgents';
 import { ChatFollowups } from 'vs/workbench/contrib/chat/browser/chatFollowups';
+import { IAction } from 'vs/base/common/actions';
 
 const defaultAriaLabel = localize('aria-label', "Inline Chat Input");
 
@@ -109,6 +107,7 @@ export const _inputEditorOptions: IEditorConstructionOptions = {
 	suggest: {
 		showIcons: false,
 		showSnippets: false,
+		showWords: true,
 		showStatusBar: false,
 	},
 	wordWrap: 'on',
@@ -170,21 +169,20 @@ export class InlineChatWidget {
 					]),
 					h('div.toolbar@editorToolbar'),
 				]),
+				h('div.widget-toolbar@widgetToolbar')
 			]),
 			h('div.progress@progress'),
 			h('div.previewDiff.hidden@previewDiff'),
 			h('div.previewCreateTitle.show-file-icons@previewCreateTitle'),
 			h('div.previewCreate.hidden@previewCreate'),
 			h('div.chatMessage.hidden@chatMessage', [
-				h('div.chatMessageContent@chatMessageContent')
-			]),
-			h('div.markdownMessage.hidden@markdownMessage', [
-				h('div.message@message'),
+				h('div.chatMessageContent@chatMessageContent'),
 				h('div.messageActions@messageActions')
 			]),
 			h('div.followUps.hidden@followUps'),
 			h('div.status@status', [
 				h('div.label.info.hidden@infoLabel'),
+				h('div.actions.hidden@extraToolbar'),
 				h('div.actions.hidden@statusToolbar'),
 				h('div.label.status.hidden@statusLabel'),
 				h('div.actions.hidden@feedbackToolbar'),
@@ -215,7 +213,6 @@ export class InlineChatWidget {
 	private readonly _previewCreateEditor: Lazy<ICodeEditor>;
 	private readonly _previewCreateDispoable = this._store.add(new MutableDisposable());
 
-
 	private readonly _onDidChangeHeight = this._store.add(new MicrotaskEmitter<void>());
 	readonly onDidChangeHeight: Event<void> = Event.filter(this._onDidChangeHeight.event, _ => !this._isLayouting);
 
@@ -231,12 +228,12 @@ export class InlineChatWidget {
 
 	private _slashCommandContentWidget: SlashCommandContentWidget;
 
-	private readonly _markdownRenderer: MarkdownRenderer;
 	private readonly _editorOptions: ChatEditorOptions;
-	private _codeBlockDisposables = this._store.add(new DisposableStore());
 	private _chatMessageDisposables = this._store.add(new DisposableStore());
 	private _followUpDisposables = this._store.add(new DisposableStore());
 
+	private _chatMessage: MarkdownString | undefined;
+
 	constructor(
 		private readonly parentEditor: ICodeEditor,
 		_options: IInlineChatWidgetConstructionOptions,
@@ -247,7 +244,6 @@ export class InlineChatWidget {
 		@IInstantiationService private readonly _instantiationService: IInstantiationService,
 		@IAccessibilityService private readonly _accessibilityService: IAccessibilityService,
 		@IConfigurationService private readonly _configurationService: IConfigurationService,
-		@IContextMenuService private readonly _contextMenuService: IContextMenuService,
 		@IAccessibleViewService private readonly _accessibleViewService: IAccessibleViewService,
 		@IEditorWorkerService private readonly _editorWorkerService: IEditorWorkerService,
 		@ILogService private readonly _logService: ILogService,
@@ -270,8 +266,8 @@ export class InlineChatWidget {
 		this._store.add(this._inputEditor.onDidChangeModelContent(() => this._onDidChangeInput.fire(this)));
 		this._store.add(this._inputEditor.onDidLayoutChange(() => this._onDidChangeHeight.fire()));
 		this._store.add(this._inputEditor.onDidContentSizeChange(() => this._onDidChangeHeight.fire()));
-		this._store.add(addDisposableListener(this._elements.message, 'focus', () => this._ctxResponseFocused.set(true)));
-		this._store.add(addDisposableListener(this._elements.message, 'blur', () => this._ctxResponseFocused.reset()));
+		this._store.add(addDisposableListener(this._elements.chatMessageContent, 'focus', () => this._ctxResponseFocused.set(true)));
+		this._store.add(addDisposableListener(this._elements.chatMessageContent, 'blur', () => this._ctxResponseFocused.reset()));
 
 		this._store.add(this._configurationService.onDidChangeConfiguration(e => {
 			if (e.affectsConfiguration(AccessibilityVerbositySettingId.InlineChat)) {
@@ -283,7 +279,6 @@ export class InlineChatWidget {
 		this._inputModel = this._store.add(this._modelService.getModel(uri) ?? this._modelService.createModel('', null, uri));
 		this._inputEditor.setModel(this._inputModel);
 
-		this._markdownRenderer = this._store.add(_instantiationService.createInstance(MarkdownRenderer, {}));
 		this._editorOptions = this._store.add(_instantiationService.createInstance(ChatEditorOptions, undefined, editorForeground, inputBackground, editorBackground));
 
 
@@ -375,28 +370,38 @@ export class InlineChatWidget {
 
 		// toolbars
 
-		const toolbar = this._instantiationService.createInstance(MenuWorkbenchToolBar, this._elements.editorToolbar, _options.menuId, {
+		this._store.add(this._instantiationService.createInstance(MenuWorkbenchToolBar, this._elements.editorToolbar, _options.menuId, {
 			telemetrySource: 'interactiveEditorWidget-toolbar',
 			toolbarOptions: { primaryGroup: 'main' }
-		});
-		this._store.add(toolbar);
+		}));
 
 		this._progressBar = new ProgressBar(this._elements.progress);
 		this._store.add(this._progressBar);
 
-		const workbenchMenubarOptions: IMenuWorkbenchButtonBarOptions = {
+
+		this._store.add(this._instantiationService.createInstance(MenuWorkbenchToolBar, this._elements.widgetToolbar, MENU_INLINE_CHAT_WIDGET, {
+			telemetrySource: 'interactiveEditorWidget-toolbar',
+			toolbarOptions: { primaryGroup: 'main' }
+		}));
+
+		this._progressBar = new ProgressBar(this._elements.progress);
+		this._store.add(this._progressBar);
+
+
+		const workbenchMenubarOptions: IWorkbenchButtonBarOptions = {
 			telemetrySource: 'interactiveEditorWidget-toolbar',
 			buttonConfigProvider: action => {
 				if (action.id === ACTION_REGENERATE_RESPONSE) {
-					return { showIcon: true, showLabel: false };
-				} else if (action.id === ACTION_VIEW_IN_CHAT) {
+					return { showIcon: true, showLabel: false, isSecondary: true };
+				} else if (action.id === ACTION_VIEW_IN_CHAT || action.id === ACTION_ACCEPT_CHANGES) {
 					return { isSecondary: false };
+				} else {
+					return { isSecondary: true };
 				}
-				return undefined;
 			}
 		};
 		const statusButtonBar = this._instantiationService.createInstance(MenuWorkbenchButtonBar, this._elements.statusToolbar, _options.statusMenuId, workbenchMenubarOptions);
-		this._store.add(statusButtonBar.onDidChangeMenuItems(() => this._onDidChangeHeight.fire()));
+		this._store.add(statusButtonBar.onDidChange(() => this._onDidChangeHeight.fire()));
 		this._store.add(statusButtonBar);
 
 
@@ -423,34 +428,22 @@ export class InlineChatWidget {
 
 		this._elements.chatMessageContent.tabIndex = 0;
 		this._elements.chatMessageContent.ariaLabel = this._accessibleViewService.getOpenAriaHint(AccessibilityVerbositySettingId.InlineChat);
-		this._elements.message.tabIndex = 0;
-		this._elements.message.ariaLabel = this._accessibleViewService.getOpenAriaHint(AccessibilityVerbositySettingId.InlineChat);
 		this._elements.followUps.tabIndex = 0;
 		this._elements.followUps.ariaLabel = this._accessibleViewService.getOpenAriaHint(AccessibilityVerbositySettingId.InlineChat);
 
-
 		this._elements.statusLabel.tabIndex = 0;
 		const markdownMessageToolbar = this._instantiationService.createInstance(MenuWorkbenchToolBar, this._elements.messageActions, MENU_INLINE_CHAT_WIDGET_MARKDOWN_MESSAGE, workbenchToolbarOptions);
 		this._store.add(markdownMessageToolbar.onDidChangeMenuItems(() => this._onDidChangeHeight.fire()));
 		this._store.add(markdownMessageToolbar);
 
-		this._store.add(addDisposableListener(this._elements.root, EventType.CONTEXT_MENU, async (event: MouseEvent) => {
-			this._onContextMenu(event);
-		}));
 		this._store.add(this._configurationService.onDidChangeConfiguration(e => {
 			if (e.affectsConfiguration(AccessibilityVerbositySettingId.InlineChat)) {
-				this._elements.message.ariaLabel = this._accessibleViewService.getOpenAriaHint(AccessibilityVerbositySettingId.InlineChat);
+				this._elements.chatMessageContent.ariaLabel = this._accessibleViewService.getOpenAriaHint(AccessibilityVerbositySettingId.InlineChat);
+				this._elements.followUps.ariaLabel = this._accessibleViewService.getOpenAriaHint(AccessibilityVerbositySettingId.InlineChat);
 			}
 		}));
 	}
 
-	private _onContextMenu(e: MouseEvent) {
-		const event = new StandardMouseEvent(getWindow(this._elements.root), e);
-		this._contextMenuService.showContextMenu({
-			menuId: MENU_INLINE_CHAT_WIDGET_TOGGLE,
-			getAnchor: () => event,
-		});
-	}
 
 	private _updateAriaLabel(): void {
 		if (!this._accessibilityService.isScreenReaderOptimized()) {
@@ -478,7 +471,8 @@ export class InlineChatWidget {
 	layout(dim: Dimension) {
 		this._isLayouting = true;
 		try {
-			const innerEditorWidth = dim.width - (getTotalWidth(this._elements.editorToolbar) + 8 /* L/R-padding */);
+			const widgetToolbarWidth = getTotalWidth(this._elements.widgetToolbar);
+			const innerEditorWidth = dim.width - (getTotalWidth(this._elements.editorToolbar) + 8 /* L/R-padding */) - (widgetToolbarWidth);
 			dim = new Dimension(innerEditorWidth, dim.height);
 			if (!this._lastDim || !Dimension.equals(this._lastDim, dim)) {
 				this._lastDim = dim;
@@ -512,13 +506,12 @@ export class InlineChatWidget {
 	getHeight(): number {
 		const base = getTotalHeight(this._elements.progress) + getTotalHeight(this._elements.status);
 		const editorHeight = this._inputEditor.getContentHeight() + 12 /* padding and border */;
-		const markdownMessageHeight = getTotalHeight(this._elements.markdownMessage);
 		const followUpsHeight = getTotalHeight(this._elements.followUps);
 		const chatResponseHeight = getTotalHeight(this._elements.chatMessage);
 		const previewDiffHeight = this._previewDiffEditor.hasValue && this._previewDiffEditor.value.getModel() ? 12 + Math.min(300, Math.max(0, this._previewDiffEditor.value.getContentHeight())) : 0;
 		const previewCreateTitleHeight = getTotalHeight(this._elements.previewCreateTitle);
 		const previewCreateHeight = this._previewCreateEditor.hasValue && this._previewCreateEditor.value.getModel() ? 18 + Math.min(300, Math.max(0, this._previewCreateEditor.value.getContentHeight())) : 0;
-		return base + editorHeight + markdownMessageHeight + followUpsHeight + chatResponseHeight + previewDiffHeight + previewCreateTitleHeight + previewCreateHeight + 18 /* padding */ + 8 /*shadow*/;
+		return base + editorHeight + followUpsHeight + chatResponseHeight + previewDiffHeight + previewCreateTitleHeight + previewCreateHeight + 18 /* padding */ + 8 /*shadow*/;
 	}
 
 	updateProgress(show: boolean) {
@@ -572,6 +565,15 @@ export class InlineChatWidget {
 		this._onDidChangeHeight.fire();
 	}
 
+	private _extraButtonsCleanup = this._store.add(new MutableDisposable());
+
+	setExtraButtons(buttons: IAction[]) {
+		const bar = this._instantiationService.createInstance(WorkbenchButtonBar, this._elements.extraToolbar, { telemetrySource: 'inlineChat' });
+		bar.update(buttons);
+		this._elements.extraToolbar.classList.toggle('hidden', buttons.length === 0);
+		this._extraButtonsCleanup.value = bar;
+	}
+
 	get expansionState(): ExpansionState {
 		return this._expansionState;
 	}
@@ -581,17 +583,23 @@ export class InlineChatWidget {
 	}
 
 	get responseContent(): string | undefined {
-		return this._elements.markdownMessage.textContent ?? undefined;
+		return this._chatMessage?.value;
 	}
 
 	updateChatMessage(message: IInlineChatMessage, isIncomplete: true): IInlineChatMessageAppender;
 	updateChatMessage(message: IInlineChatMessage | undefined): void;
 	updateChatMessage(message: IInlineChatMessage | undefined, isIncomplete?: boolean): IInlineChatMessageAppender | undefined {
+		let expansionState: ExpansionState;
 		this._chatMessageDisposables.clear();
+		this._chatMessage = message ? new MarkdownString(message.message.value) : undefined;
 		const hasMessage = message?.message.value;
 		this._elements.chatMessage.classList.toggle('hidden', !hasMessage);
 		reset(this._elements.chatMessageContent);
-		if (hasMessage) {
+		let resultingAppender: IInlineChatMessageAppender | undefined;
+		if (!hasMessage) {
+			this._ctxMessageCropState.reset();
+			expansionState = ExpansionState.NOT_CROPPED;
+		} else {
 			const sessionModel = this._chatMessageDisposables.add(new ChatModel(message.providerId, undefined, this._logService, this._chatAgentService));
 			const responseModel = this._chatMessageDisposables.add(new ChatResponseModel(message.message, sessionModel, undefined, message.requestId, !isIncomplete, false, undefined));
 			const viewModel = this._chatMessageDisposables.add(new ChatResponseViewModel(responseModel, this._logService));
@@ -607,16 +615,28 @@ export class InlineChatWidget {
 			this._chatMessageDisposables.add(template.templateDisposables);
 			renderer.renderChatTreeItem(viewModel, 0, template);
 			this._chatMessageDisposables.add(renderer.onDidChangeItemHeight(() => this._onDidChangeHeight.fire()));
-			this._onDidChangeHeight.fire();
-			return {
+
+			if (this._preferredExpansionState) {
+				expansionState = this._preferredExpansionState;
+				this._preferredExpansionState = undefined;
+			} else {
+				this._updateLineClamp(ExpansionState.CROPPED);
+				expansionState = template.value.scrollHeight > template.value.clientHeight ? ExpansionState.CROPPED : ExpansionState.NOT_CROPPED;
+			}
+			this._ctxMessageCropState.set(expansionState);
+			this._updateLineClamp(expansionState);
+			resultingAppender = isIncomplete ? {
 				cancel: () => responseModel.cancel(),
 				complete: () => responseModel.complete(),
-				appendContent: (fragment: string) => responseModel.updateContent({ kind: 'markdownContent', content: new MarkdownString(fragment) }),
-			};
-		} else {
-			this._onDidChangeHeight.fire();
-			return undefined;
+				appendContent: (fragment: string) => {
+					responseModel.updateContent({ kind: 'markdownContent', content: new MarkdownString(fragment) });
+					this._chatMessage?.appendMarkdown(fragment);
+				}
+			} : undefined;
 		}
+		this._expansionState = expansionState;
+		this._onDidChangeHeight.fire();
+		return resultingAppender;
 	}
 
 	updateFollowUps(items: IChatReplyFollowup[], onFollowup: (followup: IChatReplyFollowup) => void): void;
@@ -631,53 +651,11 @@ export class InlineChatWidget {
 		this._onDidChangeHeight.fire();
 	}
 
-	updateMarkdownMessage(message: IMarkdownString | undefined) {
-		this._codeBlockDisposables.clear();
-		const hasMessage = message?.value;
-		this._elements.markdownMessage.classList.toggle('hidden', !hasMessage);
-		let expansionState: ExpansionState;
-		let textContent: string | undefined = undefined;
-		if (!hasMessage) {
-			reset(this._elements.message);
-			this._ctxMessageCropState.reset();
-			expansionState = ExpansionState.NOT_CROPPED;
-		} else {
-			let codeBlockIndex = 0;
-			const renderedMarkdown = this._codeBlockDisposables.add(this._markdownRenderer.render(message, {
-				fillInIncompleteTokens: true,
-				codeBlockRendererSync: (languageId, text) => {
-					const codeBlockPart = this._codeBlockDisposables.add(this._instantiationService.createInstance(CodeBlockPart, this._editorOptions, MenuId.ChatCodeBlock));
-					const data = { languageId, text, codeBlockIndex: codeBlockIndex++, element: undefined };
-					codeBlockPart.render(data, this._elements.message.clientWidth);
-					this._codeBlockDisposables.add(this._onDidChangeLayout.event(() => {
-						codeBlockPart.layout(this._elements.message.clientWidth);
-					}));
-					return codeBlockPart.element;
-				}
-			}));
-			textContent = renderedMarkdown.element.textContent ?? undefined;
-			if (this._preferredExpansionState) {
-				reset(this._elements.message, renderedMarkdown.element);
-				expansionState = this._preferredExpansionState;
-				this._preferredExpansionState = undefined;
-			} else {
-				this._updateLineClamp(ExpansionState.CROPPED);
-				reset(this._elements.message, renderedMarkdown.element);
-				expansionState = this._elements.message.scrollHeight > this._elements.message.clientHeight ? ExpansionState.CROPPED : ExpansionState.NOT_CROPPED;
-			}
-			this._ctxMessageCropState.set(expansionState);
-			this._updateLineClamp(expansionState);
-		}
-		this._expansionState = expansionState;
-		this._onDidChangeHeight.fire();
-		return textContent;
-	}
-
-	updateMarkdownMessageExpansionState(expansionState: ExpansionState) {
+	updateChatMessageExpansionState(expansionState: ExpansionState) {
 		this._ctxMessageCropState.set(expansionState);
-		const heightBefore = this._elements.markdownMessage.scrollHeight;
+		const heightBefore = this._elements.chatMessageContent.scrollHeight;
 		this._updateLineClamp(expansionState);
-		const heightAfter = this._elements.markdownMessage.scrollHeight;
+		const heightAfter = this._elements.chatMessageContent.scrollHeight;
 		if (heightBefore === heightAfter) {
 			this._ctxMessageCropState.set(ExpansionState.NOT_CROPPED);
 		}
@@ -685,7 +663,7 @@ export class InlineChatWidget {
 	}
 
 	private _updateLineClamp(expansionState: ExpansionState) {
-		this._elements.message.setAttribute('state', expansionState);
+		this._elements.chatMessageContent.setAttribute('state', expansionState);
 	}
 
 	updateSlashCommandUsed(command: string): void {
@@ -736,14 +714,15 @@ export class InlineChatWidget {
 		this._ctxInputEditorFocused.reset();
 
 		this.value = '';
-		this.updateMarkdownMessage(undefined);
 		this.updateChatMessage(undefined);
 		this.updateFollowUps(undefined);
 
 		reset(this._elements.statusLabel);
 		this._elements.statusLabel.classList.toggle('hidden', true);
+		this._elements.extraToolbar.classList.add('hidden');
 		this._elements.statusToolbar.classList.add('hidden');
 		this._elements.feedbackToolbar.classList.add('hidden');
+		this.updateInfo('');
 		this.hideCreatePreview();
 		this.hideEditsPreview();
 		this._onDidChangeHeight.fire();
@@ -955,7 +934,7 @@ export class InlineChatZoneWidget extends ZoneWidget {
 		}));
 
 		this.widget = this._instaService.createInstance(InlineChatWidget, this.editor, {
-			menuId: MENU_INLINE_CHAT_WIDGET,
+			menuId: MENU_INLINE_CHAT_INPUT,
 			statusMenuId: MENU_INLINE_CHAT_WIDGET_STATUS,
 			feedbackMenuId: MENU_INLINE_CHAT_WIDGET_FEEDBACK
 		});
@@ -1063,10 +1042,8 @@ export class InlineChatZoneWidget extends ZoneWidget {
 		this.container.style.marginLeft = `${marginWithoutIndentation}px`;
 	}
 
-	setWidgetMargins(position: Position, indentationWidth?: number): void {
-		if (indentationWidth === undefined) {
-			indentationWidth = this._calculateIndentationWidth(position);
-		}
+	setWidgetMargins(position: Position): void {
+		const indentationWidth = this._calculateIndentationWidth(position);
 		if (this._indentationWidth === indentationWidth) {
 			return;
 		}
diff --git a/src/vs/workbench/contrib/inlineCSChat/common/inlineCSChat.ts b/src/vs/workbench/contrib/inlineCSChat/common/inlineCSChat.ts
index 0ad48c32016..5c29afd09f1 100644
--- a/src/vs/workbench/contrib/inlineCSChat/common/inlineCSChat.ts
+++ b/src/vs/workbench/contrib/inlineCSChat/common/inlineCSChat.ts
@@ -47,17 +47,17 @@ export interface IInlineChatRequest {
 	live: boolean;
 }
 
-export type IInlineChatResponse = IInlineChatEditResponse | IInlineChatBulkEditResponse | IInlineChatMessageResponse;
+export type IInlineChatResponse = IInlineChatEditResponse | IInlineChatBulkEditResponse;
 
 export const enum InlineChatResponseType {
 	EditorEdit = 'editorEdit',
-	BulkEdit = 'bulkEdit',
-	Message = 'message'
+	BulkEdit = 'bulkEdit'
 }
 
-export const enum InlineChateResponseTypes {
-	OnlyMessages = 'onlyMessages',
+export const enum InlineChatResponseTypes {
+	Empty = 'empty',
 	OnlyEdits = 'onlyEdits',
+	OnlyMessages = 'onlyMessages',
 	Mixed = 'mixed'
 }
 
@@ -79,14 +79,6 @@ export interface IInlineChatBulkEditResponse {
 	wholeRange?: IRange;
 }
 
-export interface IInlineChatMessageResponse {
-	id: number;
-	type: InlineChatResponseType.Message;
-	message: IMarkdownString;
-	placeholder?: string;
-	wholeRange?: IRange;
-}
-
 export interface IInlineChatProgressItem {
 	markdownFragment?: string;
 	edits?: TextEdit[];
@@ -130,7 +122,6 @@ export interface IInlineChatService {
 
 export const INLINE_CHAT_ID = 'interactiveEditor';
 export const INTERACTIVE_EDITOR_ACCESSIBILITY_HELP_ID = 'interactiveEditorAccessiblityHelp';
-export const INLINE_CHAT_DECORATIONS_ID = 'interactiveEditorDecorations';
 
 export const CTX_INLINE_CHAT_HAS_PROVIDER = new RawContextKey<boolean>('inlineChatHasProvider', false, localize('inlineChatHasProvider', "Whether a provider for interactive editors exists"));
 export const CTX_INLINE_CHAT_VISIBLE = new RawContextKey<boolean>('inlineChatVisible', false, localize('inlineChatVisible', "Whether the interactive editor input is visible"));
@@ -146,14 +137,15 @@ export const CTX_INLINE_CHAT_OUTER_CURSOR_POSITION = new RawContextKey<'above' |
 export const CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST = new RawContextKey<boolean>('inlineChatHasActiveRequest', false, localize('inlineChatHasActiveRequest', "Whether interactive editor has an active request"));
 export const CTX_INLINE_CHAT_HAS_STASHED_SESSION = new RawContextKey<boolean>('inlineChatHasStashedSession', false, localize('inlineChatHasStashedSession', "Whether interactive editor has kept a session for quick restore"));
 export const CTX_INLINE_CHAT_LAST_RESPONSE_TYPE = new RawContextKey<InlineChatResponseType | undefined>('inlineChatLastResponseType', undefined, localize('inlineChatResponseType', "What type was the last response of the current interactive editor session"));
-export const CTX_INLINE_CHAT_RESPONSE_TYPES = new RawContextKey<InlineChateResponseTypes | undefined>('inlineChatResponseTypes', undefined, localize('inlineChatResponseTypes', "What type was the responses have been receieved"));
+export const CTX_INLINE_CHAT_RESPONSE_TYPES = new RawContextKey<InlineChatResponseTypes | undefined>('inlineChatResponseTypes', InlineChatResponseTypes.Empty, localize('inlineChatResponseTypes', "What type was the responses have been receieved"));
 export const CTX_INLINE_CHAT_DID_EDIT = new RawContextKey<boolean>('inlineChatDidEdit', undefined, localize('inlineChatDidEdit', "Whether interactive editor did change any code"));
 export const CTX_INLINE_CHAT_USER_DID_EDIT = new RawContextKey<boolean>('inlineChatUserDidEdit', undefined, localize('inlineChatUserDidEdit', "Whether the user did changes ontop of the inline chat"));
 export const CTX_INLINE_CHAT_LAST_FEEDBACK = new RawContextKey<'unhelpful' | 'helpful' | ''>('inlineChatLastFeedbackKind', '', localize('inlineChatLastFeedbackKind', "The last kind of feedback that was provided"));
 export const CTX_INLINE_CHAT_SUPPORT_ISSUE_REPORTING = new RawContextKey<boolean>('inlineChatSupportIssueReporting', false, localize('inlineChatSupportIssueReporting', "Whether the interactive editor supports issue reporting"));
 export const CTX_INLINE_CHAT_DOCUMENT_CHANGED = new RawContextKey<boolean>('inlineChatDocumentChanged', false, localize('inlineChatDocumentChanged', "Whether the document has changed concurrently"));
-export const CTX_INLINE_CHAT_EDIT_MODE = new RawContextKey<EditMode>('config.inlineChat.editMode', EditMode.Live);
-export const CTX_INLINE_CHAT_TOOLBAR_ICON_ENABLED = new RawContextKey<boolean>('inlineChatToolbarIconEnabled', false, localize('inlineChatToolbarIconEnabled', "Whether the toolbar icon spawning inline chat is enabled."));
+export const CTX_INLINE_CHAT_CHANGE_HAS_DIFF = new RawContextKey<boolean>('inlineChatChangeHasDiff', false, localize('inlineChatChangeHasDiff', "Whether the current change supports showing a diff"));
+export const CTX_INLINE_CHAT_CHANGE_SHOWS_DIFF = new RawContextKey<boolean>('inlineChatChangeShowsDiff', false, localize('inlineChatChangeShowsDiff', "Whether the current change showing a diff"));
+export const CTX_INLINE_CHAT_EDIT_MODE = new RawContextKey<EditMode>('config.inlineChat.mode', EditMode.Live);
 
 // --- (select) action identifier
 
@@ -163,12 +155,12 @@ export const ACTION_VIEW_IN_CHAT = 'inlineChat.viewInChat';
 
 // --- menus
 
+export const MENU_INLINE_CHAT_INPUT = MenuId.for('inlineChatInput');
 export const MENU_INLINE_CHAT_WIDGET = MenuId.for('inlineChatWidget');
 export const MENU_INLINE_CHAT_WIDGET_MARKDOWN_MESSAGE = MenuId.for('inlineChatWidget.markdownMessage');
 export const MENU_INLINE_CHAT_WIDGET_STATUS = MenuId.for('inlineChatWidget.status');
 export const MENU_INLINE_CHAT_WIDGET_FEEDBACK = MenuId.for('inlineChatWidget.feedback');
 export const MENU_INLINE_CHAT_WIDGET_DISCARD = MenuId.for('inlineChatWidget.undo');
-export const MENU_INLINE_CHAT_WIDGET_TOGGLE = MenuId.for('inlineChatWidget.toggle');
 
 // --- colors
 
@@ -183,7 +175,11 @@ export const inlineChatInputPlaceholderForeground = registerColor('inlineChatInp
 export const inlineChatInputBackground = registerColor('inlineChatInput.background', { dark: inputBackground, light: inputBackground, hcDark: inputBackground, hcLight: inputBackground }, localize('inlineChatInput.background', "Background color of the interactive editor input"));
 
 export const inlineChatDiffInserted = registerColor('inlineChatDiff.inserted', { dark: transparent(diffInserted, .5), light: transparent(diffInserted, .5), hcDark: transparent(diffInserted, .5), hcLight: transparent(diffInserted, .5) }, localize('inlineChatDiff.inserted', "Background color of inserted text in the interactive editor input"));
+export const overviewRulerInlineChatDiffInserted = registerColor('editorOverviewRuler.inlineChatInserted', { dark: transparent(diffInserted, 0.6), light: transparent(diffInserted, 0.8), hcDark: transparent(diffInserted, 0.6), hcLight: transparent(diffInserted, 0.8) }, localize('editorOverviewRuler.inlineChatInserted', 'Overview ruler marker color for inline chat inserted content.'));
+
 export const inlineChatDiffRemoved = registerColor('inlineChatDiff.removed', { dark: transparent(diffRemoved, .5), light: transparent(diffRemoved, .5), hcDark: transparent(diffRemoved, .5), hcLight: transparent(diffRemoved, .5) }, localize('inlineChatDiff.removed', "Background color of removed text in the interactive editor input"));
+export const overviewRulerInlineChatDiffRemoved = registerColor('editorOverviewRuler.inlineChatRemoved', { dark: transparent(diffRemoved, 0.6), light: transparent(diffRemoved, 0.8), hcDark: transparent(diffRemoved, 0.6), hcLight: transparent(diffRemoved, 0.8) }, localize('editorOverviewRuler.inlineChatRemoved', 'Overview ruler marker color for inline chat removed content.'));
+
 
 // settings
 
@@ -193,12 +189,6 @@ export const enum EditMode {
 	Preview = 'preview'
 }
 
-export const enum ShowGutterIcon {
-	Always = 'always',
-	MouseOver = 'mouseover',
-	Never = 'never'
-}
-
 Registry.as<IConfigurationMigrationRegistry>(ExtensionsMigration.ConfigurationMigration).registerConfigurationMigrations(
 	[{
 		key: 'interactiveEditor.editMode', migrateFn: (value: any) => {
@@ -207,40 +197,29 @@ Registry.as<IConfigurationMigrationRegistry>(ExtensionsMigration.ConfigurationMi
 	}]
 );
 
+export const enum InlineChatConfigKeys {
+	Mode = 'inlineChat.mode',
+	FinishOnType = 'inlineChat.finishOnType',
+}
+
 Registry.as<IConfigurationRegistry>(Extensions.Configuration).registerConfiguration({
 	id: 'editor',
 	properties: {
-		'inlineChat.mode': {
-			description: localize('mode', "Configure if changes crafted in the interactive editor are applied directly to the document or are previewed first."),
-			default: EditMode.Live,
+		[InlineChatConfigKeys.Mode]: {
+			description: localize('mode', "Configure if changes crafted with inline chat are applied directly to the document or are previewed first."),
+			default: EditMode.LivePreview,
 			type: 'string',
 			enum: [EditMode.LivePreview, EditMode.Preview, EditMode.Live],
 			markdownEnumDescriptions: [
 				localize('mode.livePreview', "Changes are applied directly to the document and are highlighted visually via inline or side-by-side diffs. Ending a session will keep the changes."),
 				localize('mode.preview', "Changes are previewed only and need to be accepted via the apply button. Ending a session will discard the changes."),
-				localize('mode.live', "Changes are applied directly to the document but can be highlighted via inline diffs. Ending a session will keep the changes."),
+				localize('mode.live', "Changes are applied directly to the document, can be highlighted via inline diffs, and accepted/discarded by hunks. Ending a session will keep the changes."),
 			]
 		},
-		'inlineChat.showDiff': {
-			description: localize('showDiff', "Enable/disable showing the diff when edits are generated. Works only with inlineChat.mode equal to live or livePreview."),
-			default: true,
+		[InlineChatConfigKeys.FinishOnType]: {
+			description: localize('finishOnType', "Whether to finish an inline chat session when typing outside of changed regions."),
+			default: false,
 			type: 'boolean'
 		},
-		'inlineChat.showGutterIcon': {
-			description: localize('showGutterIcon', "Controls when the gutter icon for spawning inline chat is shown."),
-			default: ShowGutterIcon.Never,
-			type: 'string',
-			enum: [ShowGutterIcon.Always, ShowGutterIcon.MouseOver, ShowGutterIcon.Never],
-			markdownEnumDescriptions: [
-				localize('showGutterIcon.always', "Always show the gutter icon."),
-				localize('showGutterIcon.mouseover', "Show the gutter icon when the mouse is over the icon."),
-				localize('showGutterIcon.never', "Never show the gutter icon."),
-			]
-		},
-		'inlineChat.showToolbarIcon': {
-			description: localize('showToolbarIcon', "Controls whether the toolbar icon spawning the inline chat is enabled."),
-			default: true,
-			type: 'boolean'
-		}
 	}
 });
diff --git a/src/vs/workbench/contrib/inlineCSChat/test/browser/inlineCSChatController.test.ts b/src/vs/workbench/contrib/inlineCSChat/test/browser/inlineCSChatController.test.ts
index abd8a72e7bb..5a730ef8b65 100644
--- a/src/vs/workbench/contrib/inlineCSChat/test/browser/inlineCSChatController.test.ts
+++ b/src/vs/workbench/contrib/inlineCSChat/test/browser/inlineCSChatController.test.ts
@@ -31,7 +31,7 @@ import { IChatAccessibilityService } from 'vs/workbench/contrib/chat/browser/cha
 import { IChatResponseViewModel } from 'vs/workbench/contrib/chat/common/chatViewModel';
 import { InlineChatController, InlineChatRunOptions, State } from 'vs/workbench/contrib/inlineChat/browser/inlineChatController';
 import { IInlineChatSessionService, InlineChatSessionService } from 'vs/workbench/contrib/inlineChat/browser/inlineChatSession';
-import { IInlineChatService, InlineChatResponseType } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
+import { IInlineChatService, InlineChatConfigKeys, InlineChatResponseType } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
 import { InlineChatServiceImpl } from 'vs/workbench/contrib/inlineChat/common/inlineChatServiceImpl';
 import { workbenchInstantiationService } from 'vs/workbench/test/browser/workbenchTestServices';
 
@@ -81,6 +81,7 @@ suite('InteractiveChatController', function () {
 	}
 
 	const store = new DisposableStore();
+	let configurationService: TestConfigurationService;
 	let editor: IActiveCodeEditor;
 	let model: ITextModel;
 	let ctrl: TestController;
@@ -94,7 +95,7 @@ suite('InteractiveChatController', function () {
 		const contextKeyService = new MockContextKeyService();
 		inlineChatService = new InlineChatServiceImpl(contextKeyService);
 
-		const configurationService = new TestConfigurationService();
+		configurationService = new TestConfigurationService();
 		configurationService.setUserConfiguration('chat', { editor: { fontSize: 14, fontFamily: 'default' } });
 		configurationService.setUserConfiguration('editor', {});
 
@@ -180,7 +181,7 @@ suite('InteractiveChatController', function () {
 		assert.ok(ctrl.getWidgetPosition() === undefined);
 	});
 
-	test('wholeRange expands to whole lines, editor selection default', async function () {
+	test('wholeRange does not expand to whole lines, editor selection default', async function () {
 
 		editor.setSelection(new Range(1, 1, 1, 3));
 		ctrl = instaService.createInstance(TestController, editor);
@@ -203,7 +204,7 @@ suite('InteractiveChatController', function () {
 
 		const session = inlineChatSessionService.getSession(editor, editor.getModel()!.uri);
 		assert.ok(session);
-		assert.deepStrictEqual(session.wholeRange.value, new Range(1, 1, 1, 6));
+		assert.deepStrictEqual(session.wholeRange.value, new Range(1, 1, 1, 3));
 
 		await ctrl.cancelSession();
 		d.dispose();
@@ -233,13 +234,16 @@ suite('InteractiveChatController', function () {
 
 		const session = inlineChatSessionService.getSession(editor, editor.getModel()!.uri);
 		assert.ok(session);
-		assert.deepStrictEqual(session.wholeRange.value, new Range(1, 1, 1, 6));
+		assert.deepStrictEqual(session.wholeRange.value, new Range(1, 1, 1, 3));
 
 		await ctrl.cancelSession();
 		d.dispose();
 	});
 
 	test('typing outside of wholeRange finishes session', async function () {
+
+		configurationService.setUserConfiguration(InlineChatConfigKeys.FinishOnType, true);
+
 		ctrl = instaService.createInstance(TestController, editor);
 		const p = ctrl.waitFor(TestController.INIT_SEQUENCE_AUTO_SEND);
 		const r = ctrl.run({ message: 'Hello', autoSend: true });
@@ -248,7 +252,7 @@ suite('InteractiveChatController', function () {
 
 		const session = inlineChatSessionService.getSession(editor, editor.getModel()!.uri);
 		assert.ok(session);
-		assert.deepStrictEqual(session.wholeRange.value, new Range(1, 1, 1, 11));
+		assert.deepStrictEqual(session.wholeRange.value, new Range(1, 1, 1, 6));
 
 		editor.setSelection(new Range(2, 1, 2, 1));
 		editor.trigger('test', 'type', { text: 'a' });
@@ -290,13 +294,13 @@ suite('InteractiveChatController', function () {
 
 		const session = inlineChatSessionService.getSession(editor, editor.getModel()!.uri);
 		assert.ok(session);
-		assert.deepStrictEqual(session.wholeRange.value, new Range(3, 1, 3, 12));
+		assert.deepStrictEqual(session.wholeRange.value, new Range(3, 1, 3, 3));
 
 		ctrl.acceptInput();
 
 		await ctrl.waitFor([State.MAKE_REQUEST, State.APPLY_RESPONSE, State.SHOW_RESPONSE, State.WAIT_FOR_INPUT]);
 
-		assert.deepStrictEqual(session.wholeRange.value, new Range(1, 1, 4, 12));
+		assert.deepStrictEqual(session.wholeRange.value, new Range(4, 1, 4, 3));
 
 		await ctrl.cancelSession();
 		await r;
diff --git a/src/vs/workbench/contrib/inlineCSChat/test/browser/inlineCSChatSession.test.ts b/src/vs/workbench/contrib/inlineCSChat/test/browser/inlineCSChatSession.test.ts
new file mode 100644
index 00000000000..1242e625ef7
--- /dev/null
+++ b/src/vs/workbench/contrib/inlineCSChat/test/browser/inlineCSChatSession.test.ts
@@ -0,0 +1,50 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+import * as assert from 'assert';
+import { URI } from 'vs/base/common/uri';
+import { mock } from 'vs/base/test/common/mock';
+import { ensureNoDisposablesAreLeakedInTestSuite } from 'vs/base/test/common/utils';
+import { Range } from 'vs/editor/common/core/range';
+import { ILanguageService } from 'vs/editor/common/languages/language';
+import { ReplyResponse } from 'vs/workbench/contrib/inlineChat/browser/inlineChatSession';
+import { IInlineChatEditResponse, InlineChatResponseType, InlineChatResponseTypes } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
+import { ITextFileService } from 'vs/workbench/services/textfile/common/textfiles';
+
+suite('ReplyResponse', function () {
+
+	ensureNoDisposablesAreLeakedInTestSuite();
+
+	test('Inline chat widget should not contain Accept and Discard buttons for responses which do not include changes. #3143', async function () {
+		const textFileService = new class extends mock<ITextFileService>() { };
+		const languageService = new class extends mock<ILanguageService>() { };
+
+		const message = { value: 'hello' };
+		const emptyMessage = { value: '' };
+
+		const raw: IInlineChatEditResponse = {
+			type: InlineChatResponseType.EditorEdit,
+			edits: [],
+			message: emptyMessage,
+			id: 1234
+		};
+
+		{
+			const res2 = new ReplyResponse(raw, emptyMessage, URI.parse('test:uri'), 1, [], '1', textFileService, languageService);
+			assert.strictEqual(res2.responseType, InlineChatResponseTypes.Empty);
+		}
+		{
+			const res1 = new ReplyResponse({ ...raw, message }, message, URI.parse('test:uri'), 1, [], '1', textFileService, languageService);
+			assert.strictEqual(res1.responseType, InlineChatResponseTypes.OnlyMessages);
+		}
+		{
+			const res3 = new ReplyResponse({ ...raw, edits: [{ text: 'EDIT', range: new Range(1, 1, 1, 1) }] }, emptyMessage, URI.parse('test:uri'), 1, [], '1', textFileService, languageService);
+			assert.strictEqual(res3.responseType, InlineChatResponseTypes.OnlyEdits);
+		}
+		{
+			const res4 = new ReplyResponse({ ...raw, edits: [{ text: 'EDIT', range: new Range(1, 1, 1, 1) }], message }, message, URI.parse('test:uri'), 1, [], '1', textFileService, languageService);
+			assert.strictEqual(res4.responseType, InlineChatResponseTypes.Mixed);
+		}
+	});
+});
